{"/home/travis/build/npmtest/node-npmtest-snoocore/test.js":"/* istanbul instrument in package npmtest_snoocore */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snoocore/lib.npmtest_snoocore.js":"/* istanbul instrument in package npmtest_snoocore */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_snoocore = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_snoocore = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-snoocore/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-snoocore && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_snoocore */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_snoocore\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_snoocore.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_snoocore.rollup.js'] =\n            local.assetsDict['/assets.npmtest_snoocore.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_snoocore.__dirname + '/lib.npmtest_snoocore.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/Snoocore.js":"// Node.js libraries\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\n// Our modules\n\nvar _Request = require('./Request');\n\nvar _Request2 = _interopRequireDefault(_Request);\n\nvar _RedditRequest = require('./RedditRequest');\n\nvar _RedditRequest2 = _interopRequireDefault(_RedditRequest);\n\nvar _Throttle = require('./Throttle');\n\nvar _Throttle2 = _interopRequireDefault(_Throttle);\n\nvar _UserConfig = require('./UserConfig');\n\nvar _UserConfig2 = _interopRequireDefault(_UserConfig);\n\nvar _OAuth = require('./OAuth');\n\nvar _OAuth2 = _interopRequireDefault(_OAuth);\n\nvar _Modhash = require('./Modhash');\n\nvar _Modhash2 = _interopRequireDefault(_Modhash);\n\nvar _httpsFile = require('./https/file');\n\nvar _httpsFile2 = _interopRequireDefault(_httpsFile);\n\nvar Snoocore = (function (_events$EventEmitter) {\n  _inherits(Snoocore, _events$EventEmitter);\n\n  _createClass(Snoocore, null, [{\n    key: 'file',\n    value: function file() {\n      return _httpsFile2['default'].apply(undefined, arguments);\n    }\n  }, {\n    key: 'version',\n    get: function get() {\n      return '3.2.0';\n    }\n  }]);\n\n  function Snoocore(userConfiguration) {\n    var _this = this;\n\n    _classCallCheck(this, Snoocore);\n\n    _get(Object.getPrototypeOf(Snoocore.prototype), 'constructor', this).call(this);\n\n    // @TODO - this is a \"god object\" of sorts.\n    this._userConfig = new _UserConfig2['default'](userConfiguration);\n\n    this._throttle = new _Throttle2['default'](this._userConfig.throttle);\n\n    this._request = new _Request2['default'](this._throttle);\n\n    this._request.on('response_error', function (responseError) {\n      _this.emit('response_error', responseError);\n    });\n\n    // Two OAuth instances. One for authenticated users, and another for\n    // Application only OAuth. Two are needed in the instance where\n    // a user wants to bypass authentication for a call - we don't want\n    // to waste time by creating a new app only instance, authenticating,\n    // etc.\n    this.oauth = new _OAuth2['default'](this._userConfig, this._request);\n    this.oauthAppOnly = new _OAuth2['default'](this._userConfig, this._request);\n\n    // Expose OAuth functions in here\n    ['getExplicitAuthUrl', 'getImplicitAuthUrl', 'getAuthUrl', 'auth', 'refresh', 'deauth', 'getRefreshToken', 'getAccessToken', 'setRefreshToken', 'setAccessToken', 'hasRefreshToken', 'hasAccessToken'].forEach(function (fn) {\n      _this[fn] = _this.oauth[fn].bind(_this.oauth);\n    });\n\n    if (this._userConfig.useBrowserCookies) {\n      this.modhash = new _Modhash2['default'](this._userConfig, this._request);\n\n      // Expose Modhash functions in here\n      ['isModhashOld', 'setModhash', 'getModhash', 'getCurrentModhash', 'refreshModhash'].forEach(function (fn) {\n        _this[fn] = _this.modhash[fn].bind(_this.modhash);\n      });\n    }\n\n    this.appOnlyAuth = this.oauthAppOnly.applicationOnlyAuth.bind(this.oauthAppOnly);\n\n    // Bubble up the  events\n    this.oauth.on('access_token_refreshed', function (accessToken) {\n      _this.emit('access_token_refreshed', accessToken);\n    });\n\n    this._redditRequest = new _RedditRequest2['default'](this._userConfig, this._request, this.oauth, this.oauthAppOnly, this.modhash);\n\n    this._redditRequest.on('access_token_expired', function (responseError) {\n      _this.emit('access_token_expired', responseError);\n    });\n\n    this._redditRequest.on('rate_limit', function (rateLimitData) {\n      _this.emit('rate_limit', rateLimitData);\n    });\n\n    this._redditRequest.on('rate_limit_reached', function (rateLimitData) {\n      // let the user know that they have gone over\n      _this.emit('rate_limit_reached', rateLimitData);\n      // Delay the next call until the rate limit reset occurs\n      _this._throttle.addTime(rateLimitData.rateLimitReset * 1000);\n    });\n\n    /*\n       Make this._redditRequest.path the primary function that we return, but\n       stick the rest of the available functions on the prototype so we\n       can use them as well.\n     */\n    var path = this._redditRequest.path.bind(this._redditRequest);\n\n    var key = undefined;\n    for (key in this) {\n      path[key] = this[key];\n    }\n\n    return path;\n  }\n\n  return Snoocore;\n})(_events2['default'].EventEmitter);\n\nexports['default'] = Snoocore;\nmodule.exports = exports['default'];\n//# sourceMappingURL=Snoocore.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/Request.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _whenDelay = require('when/delay');\n\nvar _whenDelay2 = _interopRequireDefault(_whenDelay);\n\nvar _utils = require('./utils');\n\nvar u = _interopRequireWildcard(_utils);\n\nvar _ResponseError = require('./ResponseError');\n\nvar _ResponseError2 = _interopRequireDefault(_ResponseError);\n\nvar _httpsHttpsNode = require('./https/httpsNode');\n\nvar _httpsHttpsNode2 = _interopRequireDefault(_httpsHttpsNode);\n\nvar _httpsHttpsBrowser = require('./https/httpsBrowser');\n\nvar _httpsHttpsBrowser2 = _interopRequireDefault(_httpsHttpsBrowser);\n\nvar rawHttps = u.isNode() ? _httpsHttpsNode2['default'] : _httpsHttpsBrowser2['default'];\n\nvar Request = (function (_events$EventEmitter) {\n  _inherits(Request, _events$EventEmitter);\n\n  function Request(throttle) {\n    _classCallCheck(this, Request);\n\n    _get(Object.getPrototypeOf(Request.prototype), 'constructor', this).call(this);\n    this._throttle = throttle;\n  }\n\n  /*\n     Makes an https call with a given endpoint.\n      If an error handler is provided, it will call it in\n     the case of a returned status that is not 2xx / success.\n      If the errorHandler results in a rejected promise, then we will NOT\n     retry the endpoint and reject with the given error.\n   */\n\n  _createClass(Request, [{\n    key: 'https',\n    value: function https(endpoint, responseErrorHandler) {\n      var _this = this;\n\n      return this._throttle.wait().then(function () {\n\n        var reqOptions = {\n          method: endpoint.method.toUpperCase(),\n          hostname: endpoint.hostname,\n          path: endpoint.computedPath,\n          headers: endpoint.headers,\n          useBrowserCookies: endpoint._userConfig.useBrowserCookies\n        };\n\n        // @TODO Node.js has issues if you set it to 80?\n        if (endpoint.port !== 80) {\n          reqOptions.port = endpoint.port;\n        }\n\n        var formData = endpoint.args;\n\n        return rawHttps(reqOptions, formData).timeout(endpoint.contextOptions.requestTimeout, new _ResponseError2['default']('The request has timed out', {}, endpoint)).then(function (response) {\n\n          var statusChar = String(response._status).substring(0, 1);\n          var success = statusChar === '2';\n\n          // If success we're done!\n          if (success) {\n            return response;\n          }\n\n          // Else, retry the endpoint if we can.\n          endpoint.contextOptions.retryAttemptsLeft--;\n\n          var responseError = undefined;\n          responseError = new _ResponseError2['default']('Response Error', response, endpoint);\n\n          _this.emit('response_error', responseError);\n\n          if (endpoint.contextOptions.retryAttemptsLeft <= 0) {\n            responseError.message = 'All retry attempts exhausted.\\n\\n' + responseError.message;\n            return _when2['default'].reject(responseError);\n          }\n\n          // Use the given response error handler, or use a thin wrapper that\n          // will return the endpoint without any modifications\n          responseErrorHandler = responseErrorHandler || function (response, endpoint) {\n            return _when2['default'].resolve(endpoint);\n          };\n\n          // Call the error handler. If not rejected, retry the endpoint\n          // with any modifications made by the responseErrorHandler\n          return responseErrorHandler(response, endpoint).then(function (modifiedEndpoint) {\n\n            // Only have a retry delay if the endpoint had an HTTP 5xx status\n            var retryDelay = statusChar === '5' ? modifiedEndpoint.contextOptions.retryDelay : 0;\n\n            return (0, _whenDelay2['default'])(retryDelay).then(function () {\n              return _this.https(modifiedEndpoint, responseErrorHandler);\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return Request;\n})(_events2['default'].EventEmitter);\n\nexports['default'] = Request;\nmodule.exports = exports['default'];\n//# sourceMappingURL=Request.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/utils.js":"\n// checks basic globals to help determine which environment we are in\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNode = isNode;\nexports.thisOrThat = thisOrThat;\nexports.thisOrThrow = thisOrThrow;\n\nfunction isNode() {\n  return typeof require === \"function\" && typeof exports === \"object\" && typeof module === \"object\" && typeof window === \"undefined\";\n}\n\n/*\n   Return the value of `tryThis` unless it's undefined, then return `that`\n */\n\nfunction thisOrThat(tryThis, that) {\n  return typeof tryThis !== 'undefined' ? tryThis : that;\n}\n\n/*\n   Return the value of `tryThir` or throw an error (with provided message);\n */\n\nfunction thisOrThrow(tryThis, orThrowMessage) {\n  if (typeof tryThis !== 'undefined') {\n    return tryThis;\n  }\n  throw new Error(orThrowMessage);\n}\n//# sourceMappingURL=utils.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/ResponseError.js":"/*\n   A uniform way to report response errors.\n*/\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ResponseError = (function (_Error) {\n  _inherits(ResponseError, _Error);\n\n  function ResponseError(message, response, endpoint) {\n    _classCallCheck(this, ResponseError);\n\n    _get(Object.getPrototypeOf(ResponseError.prototype), 'constructor', this).call(this);\n\n    this.message = [message, '>>> Response Status: ' + response._status, '>>> Endpoint URL: ' + endpoint.url, '>>> Arguments: ' + JSON.stringify(endpoint.args, null, 2), '>>> Response Body:', response._body].join('\\n\\n');\n\n    this.url = endpoint.url;\n    this.args = endpoint.args;\n    this.status = response._status;\n    this.body = response._body;\n    this.retryAttemptsLeft = endpoint.contextOptions.retryAttemptsLeft;\n    this.endpoint = endpoint;\n  }\n\n  return ResponseError;\n})(Error);\n\nexports['default'] = ResponseError;\nmodule.exports = exports['default'];\n//# sourceMappingURL=ResponseError.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/https/httpsNode.js":"//\n// Node requests\n//\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = https;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _https = require('https');\n\nvar _https2 = _interopRequireDefault(_https);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _form = require('./form');\n\nvar form = _interopRequireWildcard(_form);\n\n// Set to true to print useful http debug information on a lower level\nvar DEBUG_LOG = false ? console.error : function () {};\n\n/*\n   Form data can be a raw string, or an object containing key/value pairs\n */\n\nfunction https(options, formData) {\n  DEBUG_LOG('\\n\\n\\n\\n');\n  DEBUG_LOG('>>> request:\\n' + options.method + ': ' + options.hostname + options.path);\n\n  options = options || {};\n  options.headers = options.headers || {};\n\n  formData = formData || [];\n\n  var data = form.getData(formData);\n\n  options.headers['Content-Type'] = data.contentType;\n\n  if (options.method !== 'GET') {\n    options.headers['Content-Length'] = data.contentLength;\n  }\n\n  DEBUG_LOG('\\n>>> request headers\\n', options.headers);\n\n  // stick the data at the end of the url for GET requests\n  if (options.method === 'GET' && data.buffer.toString() !== '') {\n    DEBUG_LOG('\\n>>> query string:\\n', data.buffer.toString());\n    options.path += '?' + data.buffer.toString();\n  }\n\n  return _when2['default'].promise(function (resolve, reject) {\n\n    var req = _https2['default'].request(options, function (res) {\n\n      res._req = req; // attach a reference back to the request\n\n      res.setEncoding('utf8');\n      var body = '';\n      res.on('error', function (error) {\n        return reject(error);\n      });\n      res.on('data', function (chunk) {\n        body += chunk;\n      });\n      res.on('end', function () {\n        res._body = body; // attach the response body to the object\n        res._status = res.statusCode;\n        res._headers = res.headers;\n        DEBUG_LOG('\\n>>> response headers:\\n', res._headers);\n        DEBUG_LOG('\\n>>> response body:\\n', String(body).substring(0, 1000));\n        DEBUG_LOG('\\n>>> status:\\n', res.statusCode);\n        return resolve(res);\n      });\n    });\n\n    req.on('error', function (error) {\n      return reject(error);\n    });\n\n    if (options.method !== 'GET') {\n      DEBUG_LOG('\\n>>> request body:\\n', data.buffer.toString());\n      req.write(data.buffer);\n    }\n\n    req.end();\n  }).then(function (res) {\n    var canRedirect = String(res._status).substring(0, 1) === '3' && typeof res._headers.location !== 'undefined';\n\n    if (canRedirect) {\n      // Make the call again with the new hostname, path, and form data\n      var parsed = _url2['default'].parse(res._headers.location);\n      options.hostname = parsed.hostname;\n      options.path = parsed.pathname;\n      return https(options, parsed.query);\n    }\n\n    return res;\n  });\n}\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=httpsNode.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/https/form.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.getSectionBoundary = getSectionBoundary;\nexports.getEndBoundary = getEndBoundary;\nexports.encodeFieldPart = encodeFieldPart;\nexports.encodeFilePart = encodeFilePart;\nexports.getMultipartFormData = getMultipartFormData;\nexports.getData = getData;\nexports.getFormData = getFormData;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nfunction getSectionBoundary(boundary) {\n  return '--' + boundary;\n}\n\nfunction getEndBoundary(boundary) {\n  return '--' + boundary + '--';\n}\n\nfunction encodeFieldPart(boundary, key, value) {\n  return new Buffer([getSectionBoundary(boundary), '\\r\\n', 'Content-Disposition: form-data; name=\"' + key + '\"', '\\r\\n\\r\\n', value, '\\r\\n'].join(''));\n}\n\nfunction encodeFilePart(boundary, key, name, mimeType, data) {\n  return Buffer.concat([new Buffer([getSectionBoundary(boundary), '\\r\\n', 'Content-Disposition: form-data; ' + 'name=\"' + key + '\"; ' + 'filename=\"' + name + '\"', '\\r\\n', 'Content-Type: ' + mimeType, '\\r\\n\\r\\n'].join('')), data, // already a buffer\n  new Buffer('\\r\\n')]);\n}\n\n/*\n   Converts a list of parameters to form data\n\n   - `fields` - a property map of key value pairs\n   - `files` - a list of property maps of content\n   --> `type` - the type of file data\n   --> `keyname` - the name of the key corresponding to the file\n   --> `valuename` - the name of the value corresponding to the file\n   --> `dataBuffer` - A buffer containing the files data\n */\n\nfunction getMultipartFormData(boundary, fields, files) {\n\n  var dataBuffer = new Buffer(0);\n  var key;\n\n  if (fields) {\n    for (key in fields) {\n      // skip over any file fields\n      if (key === 'file') {\n        continue;\n      }\n\n      var value = fields[key];\n\n      dataBuffer = Buffer.concat([dataBuffer, encodeFieldPart(boundary, key, value)]);\n    }\n  }\n\n  if (files) {\n    for (key in files) {\n      var file = files[key];\n\n      dataBuffer = Buffer.concat([dataBuffer, encodeFilePart(boundary, file.key, file.name, file.mimeType, file.data)]);\n    }\n  }\n\n  // close with a final boundary closed with '--' at the end\n  dataBuffer = Buffer.concat([dataBuffer, new Buffer(getEndBoundary(boundary))]);\n\n  return dataBuffer;\n}\n\n/*\n   Takes an existing string or key-value pair that represents form data\n   and returns form data in the form of an Array.\n\n   If the formData is an object, and that object has a 'file' key,\n   we will assume that it is going to be a multipart request and we\n   will also assume that the file is actually a file path on the system\n   that we wish to use in the multipart data.\n */\n\nfunction getData(formData) {\n\n  var data = {\n    contentType: 'application/x-www-form-urlencoded',\n    contentLength: 0,\n    buffer: new Buffer(0)\n  };\n\n  // The data is already in a string format. There is nothing\n  // to do really\n  if (typeof formData === 'string') {\n    data.buffer = new Buffer(formData);\n  }\n\n  if (typeof formData === 'object') {\n    // The data is an object *without* a file key. We will assume\n    // that we want this data in an url encoded format\n    if (!formData.file) {\n      data.buffer = new Buffer(_querystring2['default'].stringify(formData));\n    } else {\n      // for now we only have to handle one file, with one key name of 'file'\n      var singleFile = formData.file;\n      singleFile.key = 'file';\n\n      var files = [formData.file];\n\n      var boundary = '---------Snoocore' + Math.floor(Math.random() * 10000);\n      data.contentType = 'multipart/form-data; boundary=' + boundary;\n      data.buffer = getMultipartFormData(boundary, formData, files);\n    }\n  }\n\n  data.contentLength = data.buffer.length;\n  return data;\n}\n\n/*\n   Takes an key-value pair and turns them into a FormData object. This is for when\n   we want to upload a file using XMLHttpRequest.\n*/\n\nfunction getFormData(formData) {\n  var data = new FormData();\n\n  for (var key in formData) {\n    if (key === 'file') {\n      data.append(key, formData[key].data, formData[key].name);\n    } else {\n      data.append(key, formData[key]);\n    }\n  }\n\n  return data;\n}\n//# sourceMappingURL=form.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/https/httpsBrowser.js":"//\n// Browser requests, mirrors the syntax of the node requests\n//\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = https;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _form = require('./form');\n\nvar form = _interopRequireWildcard(_form);\n\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#getAllResponseHeaders()\n\n// Set to true to print useful http debug information on a lower level\nvar DEBUG_LOG = false ? console.error : function () {};\n\n/**\n * Modified from https://gist.github.com/monsur/706839\n *\n * XmlHttpRequest's getAllResponseHeaders() method returns a string of response\n * headers according to the format described here:\n * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method\n * This method parses that string into a user-friendly key/value pair object.\n */\nfunction parseResponseHeaders(headerStr) {\n  var headers = {};\n  if (!headerStr) {\n    return headers;\n  }\n  var headerPairs = headerStr.split('\\r\\n');\n  for (var i = 0, len = headerPairs.length; i < len; i++) {\n    var headerPair = headerPairs[i];\n    // Can't use split() here because it does the wrong thing\n    // if the header value has the string \": \" in it.\n    var index = headerPair.indexOf(': ');\n    if (index > 0) {\n      // make all keys lowercase\n      var key = headerPair.substring(0, index).toLowerCase();\n      var val = headerPair.substring(index + 2);\n      headers[key] = val;\n    }\n  }\n  return headers;\n}\n\nfunction https(options, formData) {\n\n  DEBUG_LOG('>> browser https call');\n\n  options = options || {};\n  options.headers = options.headers || {};\n\n  var data;\n\n  if (formData.file) {\n    data = form.getFormData(formData);\n  } else {\n    data = form.getData(formData);\n    options.headers['Content-Type'] = data.contentType;\n  }\n\n  return _when2['default'].promise(function (resolve, reject) {\n\n    try {\n      if (options.method === 'GET' && data instanceof FormData) {\n        return reject(new Error('Cannot make a GET request while handling a file!'));\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n      var x = new window.XMLHttpRequest();\n\n      var url = 'https://' + options.hostname + options.path;\n\n      DEBUG_LOG('>> url: ', url);\n\n      // append the form data to the end of the url\n      if (options.method === 'GET') {\n        url += '?' + data.buffer.toString();\n      }\n\n      x.open(options.method, url, true);\n\n      if (options.useBrowserCookies) {\n        x.withCredentials = true;\n      }\n\n      Object.keys(options.headers).forEach(function (headerKey) {\n        x.setRequestHeader(headerKey, options.headers[headerKey]);\n      });\n\n      x.onreadystatechange = function () {\n        if (x.readyState > 3) {\n          // Normalize the result to match how requestNode.js works\n\n          DEBUG_LOG('finished...', x.status);\n\n          return resolve({\n            _body: x.responseText,\n            _status: x.status,\n            _headers: parseResponseHeaders(x.getAllResponseHeaders())\n          });\n        }\n      };\n\n      if (data instanceof FormData) {\n        x.send(data);\n      } else {\n        x.send(options.method === 'GET' ? null : data.buffer.toString());\n      }\n    } catch (e) {\n      return reject(e);\n    }\n  }).then(function (res) {\n    var canRedirect = String(res._status).substring(0, 1) === '3' && typeof res._headers.location !== 'undefined';\n\n    if (canRedirect) {\n      // Make the call again with the new hostname, path, and form data\n      var parsed = _url2['default'].parse(res._headers.location);\n      options.hostname = parsed.hostname;\n      options.path = parsed.pathname;\n      return https(options, parsed.query);\n    }\n\n    return res;\n  });\n}\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=httpsBrowser.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/RedditRequest.js":"\n// node modules\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\n// npm modules\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _whenDelay = require('when/delay');\n\nvar _whenDelay2 = _interopRequireDefault(_whenDelay);\n\nvar _he = require('he');\n\nvar _he2 = _interopRequireDefault(_he);\n\n// our modules\n\nvar _Request = require('./Request');\n\nvar _Request2 = _interopRequireDefault(_Request);\n\nvar _Endpoint = require('./Endpoint');\n\nvar _Endpoint2 = _interopRequireDefault(_Endpoint);\n\nvar _ResponseError = require('./ResponseError');\n\nvar _ResponseError2 = _interopRequireDefault(_ResponseError);\n\n/*\n   A collection of functions that deal with requesting data from the\n   reddit API.\n */\n\nvar RedditRequest = (function (_events$EventEmitter) {\n  _inherits(RedditRequest, _events$EventEmitter);\n\n  function RedditRequest(userConfig, request, oauth, oauthAppOnly, modhash) {\n    _classCallCheck(this, RedditRequest);\n\n    _get(Object.getPrototypeOf(RedditRequest.prototype), 'constructor', this).call(this);\n    this._request = request;\n    this._userConfig = userConfig;\n    this._oauth = oauth;\n    this._oauthAppOnly = oauthAppOnly;\n    this._modhash = modhash;\n  }\n\n  /*\n     Currently application only?\n      If we do not have an access token and there is no way\n     to get a new access token then yes! We are application\n     only oauth.\n   */\n\n  _createClass(RedditRequest, [{\n    key: 'isApplicationOnly',\n    value: function isApplicationOnly() {\n      return !this._oauth.hasAccessToken() && !this._oauth.canRefreshAccessToken();\n    }\n\n    /*\n       Are we currently authenticated?\n     */\n  }, {\n    key: 'isAuthenticated',\n    value: function isAuthenticated() {\n      return this.isApplicationOnly() ? this._oauthAppOnly.hasAccessToken() : this._oauth.hasAccessToken();\n    }\n\n    /*\n       Builds up the headers for an endpoint.\n     */\n  }, {\n    key: 'buildHeaders',\n    value: function buildHeaders() {\n      var contextOptions = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var headers = {};\n\n      if (this._userConfig.isNode) {\n        // Can't set User-Agent in browser\n        headers['User-Agent'] = this._userConfig.userAgent;\n      }\n\n      if (this._userConfig.useBrowserCookies) {\n        headers['X-User-Agent'] = this._userConfig.userAgent;\n\n        if (this._modhash.hasModhash() && !this._modhash.isModhashOld()) {\n          headers['X-Modhash'] = this._modhash.getCurrentModhash();\n        }\n      }\n\n      if (!this._userConfig.useBrowserCookies) {\n        if (contextOptions.bypassAuth || this.isApplicationOnly()) {\n          headers['Authorization'] = this._oauthAppOnly.getAuthorizationHeader();\n        } else {\n          headers['Authorization'] = this._oauth.getAuthorizationHeader();\n        }\n      }\n\n      return headers;\n    }\n\n    /*\n       Call the reddit api.\n     */\n  }, {\n    key: 'callRedditApi',\n    value: function callRedditApi(endpoint) {\n      var _this = this;\n\n      // Authenticate if needed before making a call.\n      //\n      // Eliminates unwanted 401 errors when making initial calls\n      // on Application only OAuth & Script instances where calling\n      // `.auth()` isn't required.\n      var auth = this.isAuthenticated() ? _when2['default'].resolve() : (function () {\n        return _this.authenticate(endpoint).then(function () {\n          // rebuild endpoint with new headers\n          endpoint = new _Endpoint2['default'](_this._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);\n        });\n      })();\n\n      return auth.then(function () {\n        var requestPromise = _this._request.https(endpoint, _this.responseErrorHandler.bind(_this));\n\n        return requestPromise.then(function (response) {\n          return _this.handleSuccessResponse(response, endpoint);\n        });\n      });\n    }\n\n    /*\n       Authenticate with the appropriate OAuth type for a given\n       endpoint\n     */\n  }, {\n    key: 'authenticate',\n    value: function authenticate(endpoint) {\n      var authPromise = undefined;\n\n      // If we are application only, or are bypassing authentication\n      // therefore we're using application only OAuth\n      if (this._userConfig.useBrowserCookies) {\n        if (endpoint.method === 'post') {\n          authPromise = this._modhash.getModhash();\n        } else {\n          authPromise = _when2['default'].resolve();\n        }\n      } else if (this.isApplicationOnly() || endpoint.contextOptions.bypassAuth) {\n        authPromise = this._oauthAppOnly.applicationOnlyAuth();\n      } else if (this._oauth.canRefreshAccessToken()) {\n        // If we have been authenticated with a permanent refresh token use it\n        if (this._oauth.hasRefreshToken()) {\n          authPromise = this._oauth.refresh();\n        }\n        // If we are OAuth type script we can call `.auth` again\n        else if (this._userConfig.isOAuthType('script')) {\n            authPromise = this._oauth.auth();\n          }\n      }\n      // No way to authenticate\n      else {\n          return _when2['default'].reject(new Error('Unable to authenticate'));\n        }\n\n      return authPromise;\n    }\n\n    /*\n       Handle a request errors from reddit. This is usually caused when our\n       access_token has expired, or reddit servers are under heavy load.\n        If we can't renew our access token, we throw an error / emit the\n       'access_token_expired' event that users can then handle to\n       re-authenticatet clients\n        If we can renew our access token, we try to reauthenticate, and call the\n       reddit endpoint again.\n     */\n  }, {\n    key: 'responseErrorHandler',\n    value: function responseErrorHandler(response, endpoint) {\n      var _this2 = this;\n\n      // - - -\n      // Check headers for more specific errors.\n\n      var wwwAuth = response._headers['www-authenticate'];\n\n      if (wwwAuth && wwwAuth.indexOf('insufficient_scope') !== -1) {\n        return _when2['default'].reject(new _ResponseError2['default']('Insufficient scopes provided for this call', response, endpoint));\n      }\n\n      // - - -\n      // 404 - Page not found\n      if (response._status === 404) {\n        var msg = 'Page not found. Is this a valid endpoint?';\n        return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));\n      }\n\n      // - - -\n      // Access token has expired\n      if (response._status === 401 && !this._userConfig.useBrowserCookies) {\n\n        // Atempt to get a new access token!\n        var reauthPromise = this.authenticate(endpoint);\n\n        return reauthPromise.then(function () {\n          // refresh the authentication headers for this endpoint\n          endpoint.setHeaders(_this2.buildHeaders(endpoint.contextOptions));\n\n          var modifiedEndpoint = new _Endpoint2['default'](_this2._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this2.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);\n\n          return _when2['default'].resolve(modifiedEndpoint);\n        })['catch'](function (error) {\n          _this2.emit('access_token_expired');\n\n          var msg = 'Access token has expired. Listen for ' + 'the \"access_token_expired\" event to ' + 'handle this gracefully in your app.';\n          return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));\n        });\n      }\n\n      // - - -\n      // Access token has expired and we're trying to authenticate without OAuth\n      if (response._status === 401 && !this._userConfig.useBrowserCookies) {\n        var msg = 'Access token required to access this endpoint.';\n        return _when2['default'].reject(new _ResponseError2['default'](msg, response, endpoint));\n      }\n\n      // - - -\n      // Reddit servers are busy. Can't do much here.\n\n      if (String(response._status).substring(0, 1) === '5') {\n        var modifiedEndpoint = new _Endpoint2['default'](this._userConfig, endpoint.hostname, endpoint.method, endpoint.path, this.buildHeaders(endpoint.contextOptions), endpoint.givenArgs, endpoint.contextOptions, endpoint.port);\n\n        return _when2['default'].resolve(modifiedEndpoint);\n      }\n\n      // - - -\n      // At the end of the day, we just throw an error stating that there\n      // is nothing we can do & give general advice\n      return _when2['default'].reject(new _ResponseError2['default']('This call failed. ' + 'Does this call require a user? ' + 'Is the user missing reddit gold? ' + 'Trying to change a subreddit that the user does not moderate? ' + 'This is an unrecoverable error. Check the rest of the ' + 'error message for more information.', response, endpoint));\n    }\n\n    /*\n       Handle reddit response status of 2xx.\n        Finally return the data if there were no problems.\n     */\n  }, {\n    key: 'handleSuccessResponse',\n    value: function handleSuccessResponse(response, endpoint) {\n\n      var data = response._body || '';\n\n      if (endpoint.contextOptions.decodeHtmlEntities) {\n        data = _he2['default'].decode(data);\n      }\n\n      // Attempt to parse some JSON, otherwise continue on (may be empty, or text)\n      try {\n        data = JSON.parse(data);\n\n        // Reddit isn't always honest in their response status. Check for\n        // any errors in 2xx http statuses\n\n        // data.json.errors\n        if (data.json && data.json.errors && data.json.errors.length > 0) {\n          return _when2['default'].reject(new _ResponseError2['default']('', response, endpoint));\n        }\n\n        // data.json.error\n        if (data.json && data.json.error) {\n          return _when2['default'].reject(new _ResponseError2['default']('', response, endpoint));\n        }\n      } catch (e) {}\n\n      var rateLimitRemaining = response._headers['x-ratelimit-remaining'];\n      var rateLimitUsed = response._headers['x-ratelimit-used'];\n      var rateLimitReset = response._headers['x-ratelimit-reset'];\n\n      var rateLimitData = {\n        rateLimitRemaining: rateLimitRemaining ? Number(rateLimitRemaining) : void 0,\n        rateLimitUsed: rateLimitUsed ? Number(rateLimitUsed) : void 0,\n        rateLimitReset: rateLimitReset ? Number(rateLimitReset) : void 0\n      };\n\n      if (typeof rateLimitData.rateLimitUsed !== 'undefined') {\n        this.emit('rate_limit', rateLimitData);\n      }\n\n      // Using a test variable\n      // this._userConfig.__test.rateLimitRemainingCutoff\n      // it's default value is \"0\", however in the tests cases this\n      // would take too long.\n      var cutoff = this._userConfig.__test.rateLimitRemainingCutoff;\n\n      if (typeof rateLimitData.rateLimitRemaining !== 'undefined' && Number(rateLimitRemaining) <= cutoff) {\n        this.emit('rate_limit_reached', rateLimitData);\n      }\n\n      if (this._userConfig.useBrowserCookies && data.data && data.data.modhash && data.data.modhash.length) {\n        this._modhash.setModhash(data.data.modhash);\n      }\n\n      return _when2['default'].resolve(data);\n    }\n\n    /*\n       Listing support.\n     */\n  }, {\n    key: 'getListing',\n    value: function getListing(endpoint) {\n      var _this3 = this;\n\n      // number of results that we have loaded so far. It will\n      // increase / decrease when calling next / previous.\n      var count = 0;\n      var limit = endpoint.args.limit || 25;\n      // keep a reference to the start of this listing\n      var start = endpoint.args.after || null;\n\n      var getSlice = function getSlice(endpoint) {\n\n        return _this3.callRedditApi(endpoint).then(function () {\n          var result = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n          var slice = {};\n          var listing = result;\n\n          slice.get = result;\n\n          if (result instanceof Array) {\n            if (typeof endpoint.contextOptions.listingIndex === 'undefined') {\n              throw new Error('Must specify a `listingIndex` for this listing.');\n            }\n\n            listing = result[endpoint.contextOptions.listingIndex];\n          }\n\n          slice.count = count;\n\n          slice.before = listing.data.before || null;\n          slice.after = listing.data.after || null;\n          slice.allChildren = listing.data.children || [];\n\n          slice.empty = slice.allChildren.length === 0;\n\n          slice.children = slice.allChildren.filter(function (child) {\n            child.data = child.data || {};\n            return !child.data.stickied;\n          });\n\n          slice.stickied = slice.allChildren.filter(function (child) {\n            child.data = child.data || {};\n            return child.data.stickied;\n          });\n\n          slice.next = function () {\n            count += limit;\n\n            var newArgs = endpoint.givenArgs;\n            newArgs.before = null;\n            newArgs.after = slice.children[slice.children.length - 1].data.name;\n            newArgs.count = count;\n            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));\n          };\n\n          slice.previous = function () {\n            count -= limit;\n\n            var newArgs = endpoint.givenArgs;\n            newArgs.before = slice.children[0].data.name;\n            newArgs.after = null;\n            newArgs.count = count;\n            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));\n          };\n\n          slice.start = function () {\n            count = 0;\n\n            var newArgs = endpoint.givenArgs;\n            newArgs.before = null;\n            newArgs.after = start;\n            newArgs.count = count;\n            return getSlice(new _Endpoint2['default'](_this3._userConfig, endpoint.hostname, endpoint.method, endpoint.path, _this3.buildHeaders(endpoint.contextOptions), newArgs, endpoint.contextOptions, endpoint.port));\n          };\n\n          slice.requery = function () {\n            return getSlice(endpoint);\n          };\n\n          return slice;\n        });\n      };\n\n      return getSlice(endpoint);\n    }\n\n    /*\n       Enable path syntax support, e.g. this.path('/path/to/$endpoint/etc')\n        Can take an url as well, but the first part of the url is chopped\n       off because it is not needed. We will always use the server oauth\n       to call the API...\n        e.g. https://www.example.com/api/v1/me\n        will only use the path: /api/v1/me\n     */\n  }, {\n    key: 'path',\n    value: function path(urlOrPath) {\n      var _this4 = this;\n\n      var parsed = _url2['default'].parse(urlOrPath);\n      var path = parsed.pathname;\n\n      var calls = {};\n\n      ['get', 'post', 'put', 'patch', 'delete', 'update'].forEach(function (verb) {\n        calls[verb] = function (userGivenArgs, userContextOptions) {\n          return _this4.callRedditApi(new _Endpoint2['default'](_this4._userConfig, _this4._userConfig.serverOAuth, verb, path, _this4.buildHeaders(userContextOptions), userGivenArgs, userContextOptions, _this4._userConfig.serverOAuthPort));\n        };\n      });\n\n      // Add listing support\n      calls.listing = function (userGivenArgs, userContextOptions) {\n        return _this4.getListing(new _Endpoint2['default'](_this4._userConfig, _this4._userConfig.serverOAuth, 'get', path, _this4.buildHeaders(userContextOptions), userGivenArgs, userContextOptions, _this4._userConfig.serverOAuthPort));\n      };\n\n      return calls;\n    }\n  }]);\n\n  return RedditRequest;\n})(_events2['default'].EventEmitter);\n\nexports['default'] = RedditRequest;\nmodule.exports = exports['default'];\n//# sourceMappingURL=RedditRequest.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/Endpoint.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nexports.replaceUrlParams = replaceUrlParams;\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _utils = require('./utils');\n\nvar u = _interopRequireWildcard(_utils);\n\nvar Endpoint = (function () {\n  function Endpoint(userConfig, hostname, method, path) {\n    var headers = arguments.length <= 4 || arguments[4] === undefined ? {} : arguments[4];\n    var givenArgs = arguments.length <= 5 || arguments[5] === undefined ? {} : arguments[5];\n    var givenContextOptions = arguments.length <= 6 || arguments[6] === undefined ? {} : arguments[6];\n    var port = arguments.length <= 7 || arguments[7] === undefined ? 80 : arguments[7];\n\n    _classCallCheck(this, Endpoint);\n\n    this._userConfig = userConfig;\n\n    this.hostname = hostname;\n    this.port = port;\n    this.method = method;\n    this.path = path;\n    this.headers = headers;\n\n    this.contextOptions = this.normalizeContextOptions(givenContextOptions);\n\n    this.givenArgs = givenArgs;\n    this.args = this.buildArgs();\n    this.url = this.buildUrl();\n    this.computedPath = _url2['default'].parse(this.url).path;\n  }\n\n  /*\n     Takes an url, and an object of url parameters and replaces\n     them, e.g.\n  \n     endpointUrl:\n     'http://example.com/$foo/$bar/test.html'\n  \n     this.givenArgs: { $foo: 'hello', $bar: 'world' }\n  \n     would output:\n  \n     'http://example.com/hello/world/test.html'\n   */\n\n  _createClass(Endpoint, [{\n    key: 'setHeaders',\n    value: function setHeaders(headers) {\n      this.headers = headers;\n    }\n\n    /*\n       Returns a set of options that effect how each call to reddit behaves.\n     */\n  }, {\n    key: 'normalizeContextOptions',\n    value: function normalizeContextOptions(givenContextOptions) {\n\n      var cOptions = givenContextOptions || {};\n\n      // by default we do not bypass authentication\n      cOptions.bypassAuth = u.thisOrThat(cOptions.bypassAuth, false);\n\n      // decode html enntities for this call?\n      cOptions.decodeHtmlEntities = u.thisOrThat(cOptions.decodeHtmlEntities, this._userConfig.decodeHtmlEntities);\n\n      // how many attempts left do we have to retry an endpoint?\n\n      // use the given retryAttemptsLeft, or the retryAttempts passed in the\n      // context options if not specified\n      cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft, cOptions.retryAttempts);\n\n      // use the given retryAttemptsLeft, or the retryAttempts passed in the\n      // user configuration\n      cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft, this._userConfig.retryAttempts);\n\n      // delay between retrying an endpoint\n      cOptions.retryDelay = u.thisOrThat(cOptions.retryDelay, this._userConfig.retryDelay);\n\n      // milliseconds before a request times out\n      cOptions.requestTimeout = u.thisOrThat(cOptions.requestTimeout, this._userConfig.requestTimeout);\n\n      // how many reauthentication attempts do we have left?\n      cOptions.reauthAttemptsLeft = u.thisOrThat(cOptions.reauthAttemptsLeft, cOptions.retryAttemptsLeft);\n\n      return cOptions;\n    }\n\n    /*\n       Build the arguments that we will send to reddit in our\n       request. These customize the request that we send to reddit\n     */\n  }, {\n    key: 'buildArgs',\n    value: function buildArgs() {\n      var args = {};\n\n      // Skip any url parameters (e.g. items that begin with $)\n      for (var key in this.givenArgs) {\n        if (key.substring(0, 1) !== '$') {\n          args[key] = this.givenArgs[key];\n        }\n      }\n\n      var apiType = u.thisOrThat(this.contextOptions.api_type, this._userConfig.apiType);\n\n      if (apiType) {\n        args.api_type = apiType;\n      }\n\n      return args;\n    }\n\n    /*\n       Builds the URL that we will query reddit with.\n     */\n  }, {\n    key: 'buildUrl',\n    value: function buildUrl() {\n      var url = this.hostname;\n\n      if (this.port !== 80) {\n        url += ':' + this.port;\n      }\n\n      var path = this.path;\n      if (path.substring(0, 1) !== '/') {\n        path = '/' + path;\n      }\n\n      url += path;\n\n      url = replaceUrlParams(url, this.givenArgs);\n      url = url.replace('//', '/');\n      url = 'https://' + url;\n      return url;\n    }\n  }]);\n\n  return Endpoint;\n})();\n\nexports['default'] = Endpoint;\n\nfunction replaceUrlParams(endpointUrl, givenArgs) {\n  // nothing to replace!\n  if (endpointUrl.indexOf('$') === -1) {\n    return endpointUrl;\n  }\n\n  // pull out variables from the url\n  var params = endpointUrl.match(/\\$[\\w\\.]+/g);\n\n  // replace with the argument provided\n  params.forEach(function (param) {\n    if (typeof givenArgs[param] === 'undefined') {\n      throw new Error('missing required url parameter ' + param);\n    }\n    endpointUrl = endpointUrl.replace(param, givenArgs[param]);\n  });\n\n  return endpointUrl;\n}\n//# sourceMappingURL=Endpoint.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/Throttle.js":"/*\n   A basic throttle manager. Exposes 1 functoin `wait` that\n   will return a promise that resolves once we've waited the proper\n   amount of time, e.g.\n\n   var throttle = new Throttle();\n\n   throttle.wait() // resolves after 1ms\n   throttle.wait() // resolves after 10001ms\n   throttle.wait() // resolves after 2001ms\n\n */\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _whenDelay = require('when/delay');\n\nvar _whenDelay2 = _interopRequireDefault(_whenDelay);\n\nvar Throttle = (function () {\n  function Throttle() {\n    var throttleMs = arguments.length <= 0 || arguments[0] === undefined ? 1000 : arguments[0];\n\n    _classCallCheck(this, Throttle);\n\n    this._throttleMs = throttleMs;\n\n    /*\n       The current throttle delay before a request will go through\n       increments every time a call is made, and is reduced when a\n       call finishes.\n        Time is added & removed based on the throttle variable.\n     */\n    this._throttleDelay = 1;\n  }\n\n  _createClass(Throttle, [{\n    key: 'wait',\n    value: function wait() {\n      var _this = this;\n\n      // resolve this promise after the current throttleDelay\n      var delayPromise = (0, _whenDelay2['default'])(this._throttleDelay);\n\n      // add throttleMs to the total throttleDelay\n      this._throttleDelay += this._throttleMs;\n\n      // after throttleMs time, subtract throttleMs from\n      // the throttleDelay\n      setTimeout(function () {\n        _this._throttleDelay -= _this._throttleMs;\n      }, this._throttleMs);\n\n      return delayPromise;\n    }\n\n    /*\n       Time in milliseconds to add to the throttle delay\n    */\n  }, {\n    key: 'addTime',\n    value: function addTime(timeMs) {\n      this._throttleDelay += timeMs;\n    }\n  }]);\n\n  return Throttle;\n})();\n\nexports['default'] = Throttle;\nmodule.exports = exports['default'];\n//# sourceMappingURL=Throttle.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/UserConfig.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _utils = require('./utils');\n\nvar u = _interopRequireWildcard(_utils);\n\n/*\n   A class made up of the user configuration.\n\n   Normalizes the configuraiton & checks for simple errors.\n\n   Provides some helper functons for getting user set values.\n */\n\nvar UserConfig = (function () {\n  function UserConfig(userConfiguration) {\n    _classCallCheck(this, UserConfig);\n\n    //\n    // - - - CONFIGURATION VALUES - - -\n    //\n\n    var missingMsg = 'Missing required userConfiguration value ';\n\n    // ** IDENFIFICATION\n    this.userAgent = u.thisOrThrow(userConfiguration.userAgent, 'Missing required userConfiguration value `userAgent`');\n\n    this.isNode = u.thisOrThat(userConfiguration.browser, u.isNode());\n\n    this.mobile = u.thisOrThat(userConfiguration.mobile, false);\n\n    this.useBrowserCookies = u.thisOrThat(userConfiguration.useBrowserCookies, false);\n\n    if (userConfiguration.apiServerUri) {\n      userConfiguration.serverOAuth = userConfiguration.apiServerUri;\n    }\n\n    if (userConfiguration.authServerUri) {\n      userConfiguration.serverWWW = userConfiguration.authServerUri;\n    }\n\n    // ** SERVERS\n    if (this.useBrowserCookies) {\n      this.serverOAuth = u.thisOrThat(userConfiguration.serverOAuth, 'www.reddit.com');\n    } else {\n      this.serverOAuth = u.thisOrThat(userConfiguration.serverOAuth, 'oauth.reddit.com');\n    }\n\n    this.serverWWW = u.thisOrThat(userConfiguration.serverWWW, 'www.reddit.com');\n    this.serverOAuthPort = u.thisOrThat(userConfiguration.serverOAuthPort, 80);\n    this.serverWWWPort = u.thisOrThat(userConfiguration.serverWWWPort, 80);\n\n    // ** CALL MODIFICATIONS\n    this.throttle = u.thisOrThat(userConfiguration.throttle, 1000);\n\n    this.decodeHtmlEntities = u.thisOrThat(userConfiguration.decodeHtmlEntities, false);\n\n    this.apiType = u.thisOrThat(userConfiguration.apiType, 'json');\n\n    // ** RETRY ATTEMPTS\n    this.retryAttempts = u.thisOrThat(userConfiguration.retryAttempts, 60);\n\n    this.retryDelay = u.thisOrThat(userConfiguration.retryDelay, 5000);\n\n    this.requestTimeout = u.thisOrThat(userConfiguration.requestTimeout, 20000);\n\n    // ** OAUTH\n    this.oauth = u.thisOrThat(userConfiguration.oauth, {});\n\n    this.oauth.scope = u.thisOrThat(this.oauth.scope, []);\n\n    this.oauth.deviceId = u.thisOrThat(this.oauth.deviceId, 'DO_NOT_TRACK_THIS_DEVICE');\n    this.oauth.duration = u.thisOrThat(this.oauth.duration, 'temporary');\n\n    if (this.useBrowserCookies) {\n      this.oauth.type = u.thisOrThat(this.oauth.type, '');\n      this.oauth.key = u.thisOrThat(this.oauth.key, '');\n    } else {\n      this.oauth.type = u.thisOrThrow(this.oauth.type, missingMsg + '`oauth.type`');\n      this.oauth.key = u.thisOrThrow(this.oauth.key, missingMsg + '`oauth.key`');\n    }\n\n    //\n    // - - - VALIDATION\n    //\n\n    if (this.oauth.duration !== 'temporary' && this.oauth.duration !== 'permanent') {\n      throw new Error('Invalid `oauth.duration`. Must be one of: permanent, temporary');\n    }\n\n    if (this.oauth.deviceId !== 'DO_NOT_TRACK_THIS_DEVICE' && (this.oauth.deviceId.length < 20 || this.oauth.deviceId.length > 30)) {\n      throw new Error('Invalid device_id length. Must be 20-30 characters');\n    }\n\n    if (!this.isOAuthType('explicit') && !this.isOAuthType('implicit') && !this.isOAuthType('script') && !this.useBrowserCookies) {\n      throw new Error('Invalid `oauth.type`. Must be one of: explicit, implicit, or script');\n    }\n\n    if (!this.useBrowserCookies) {\n      if (this.isOAuthType('explicit') || this.isOAuthType('script')) {\n        this.oauth.secret = u.thisOrThrow(this.oauth.secret, missingMsg + '`oauth.secret` for type explicit/script');\n      }\n\n      if (this.isOAuthType('script')) {\n        this.oauth.username = u.thisOrThrow(this.oauth.username, missingMsg + '`oauth.username` for type script');\n        this.oauth.password = u.thisOrThrow(this.oauth.password, missingMsg + '`oauth.password` for type script');\n      }\n\n      if (this.isOAuthType('implicit') || this.isOAuthType('explicit')) {\n        this.oauth.redirectUri = u.thisOrThrow(this.oauth.redirectUri, missingMsg + '`oauth.redirectUri` for type implicit/explicit');\n      }\n    }\n\n    //\n    // TESTING CONFIGURATION\n    //\n    // Some test cases require some deep messing around with the library\n    // in order to be nice to the API server when testing.\n    //\n    // These should never be used by anything other than the test cases to\n    // modify internal variables. They are only used if needed!\n\n    /*\n       Used to determine when we have gone over the rate limit. The default\n       would be \"0\", e.g. when there are not more requests remaining in the\n       current time slot\n     */\n    this.__test = {};\n    userConfiguration.__test = userConfiguration.__test || {};\n\n    this.__test.rateLimitRemainingCutoff = u.thisOrThat(userConfiguration.__test.rateLimitRemainingCutoff, 0);\n  }\n\n  /*\n     Checks if the oauth is of a specific type, e.g.\n      isOAuthType('script')\n   */\n\n  _createClass(UserConfig, [{\n    key: 'isOAuthType',\n    value: function isOAuthType(type) {\n      return this.oauth.type === type;\n    }\n  }]);\n\n  return UserConfig;\n})();\n\nexports['default'] = UserConfig;\nmodule.exports = exports['default'];\n//# sourceMappingURL=UserConfig.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/OAuth.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _querystring = require('querystring');\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _util = require('util');\n\nvar _util2 = _interopRequireDefault(_util);\n\nvar _url = require('url');\n\nvar _url2 = _interopRequireDefault(_url);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _utils = require('./utils');\n\nvar u = _interopRequireWildcard(_utils);\n\nvar _Endpoint = require('./Endpoint');\n\nvar _Endpoint2 = _interopRequireDefault(_Endpoint);\n\nvar _ResponseError = require('./ResponseError');\n\nvar _ResponseError2 = _interopRequireDefault(_ResponseError);\n\n/*\n   Various OAuth types\n */\nvar TOKEN = {\n  EXPLICIT: 'explicit',\n  IMPLICIT: 'implicit',\n  SCRIPT: 'script',\n  APP_ONLY: 'app_only',\n  REFRESH: 'refresh',\n  INVALID: 'invalid_token' // Represents an unset/invalid token\n};\n\nexports.TOKEN = TOKEN;\n/*\n   Represents a single OAuth instance. Used primarily for internal\n   use within the Snoocore class to manage two OAuth instances -\n   Applicaton Only and an Authenticated Session.\n\n */\n\nvar OAuth = (function (_events$EventEmitter) {\n  _inherits(OAuth, _events$EventEmitter);\n\n  function OAuth(userConfig, request) {\n    _classCallCheck(this, OAuth);\n\n    _get(Object.getPrototypeOf(OAuth.prototype), 'constructor', this).call(this);\n\n    this._userConfig = userConfig;\n\n    this._request = request;\n\n    this.accessToken = TOKEN.INVALID;\n    this.refreshToken = TOKEN.INVALID;\n    this.tokenType = 'bearer';\n\n    this.scope = this.normalizeScope();\n  }\n\n  /*\n     Takes a given scope, and normalizes it to a proper string.\n   */\n\n  _createClass(OAuth, [{\n    key: 'normalizeScope',\n    value: function normalizeScope() {\n      var scope = undefined;\n      // Set to empty string if the scope if not set\n      if (typeof this._userConfig.oauth.scope === 'undefined') {\n        scope = '';\n      }\n      // convert an array into a string\n      else if (_util2['default'].isArray(this._userConfig.oauth.scope)) {\n          scope = this._userConfig.oauth.scope.join(',');\n        }\n      return scope;\n    }\n\n    /*\n       Do we have a refresh token defined?\n     */\n  }, {\n    key: 'hasRefreshToken',\n    value: function hasRefreshToken() {\n      return this.refreshToken !== TOKEN.INVALID;\n    }\n\n    /*\n       Do we have an access token defined?\n     */\n  }, {\n    key: 'hasAccessToken',\n    value: function hasAccessToken() {\n      return this.accessToken !== TOKEN.INVALID;\n    }\n\n    /*\n       Get the current refresh token used for this instance.\n     */\n  }, {\n    key: 'getRefreshToken',\n    value: function getRefreshToken() {\n      if (this.refreshToken === TOKEN.INVALID) {\n        return undefined;\n      }\n      return this.refreshToken;\n    }\n\n    /*\n       Get the current access token used for this instance.\n     */\n  }, {\n    key: 'getAccessToken',\n    value: function getAccessToken() {\n      if (this.accessToken === TOKEN.INVALID) {\n        return undefined;\n      }\n      return this.accessToken;\n    }\n\n    /*\n       Set the current refresh token used for this instance.\n     */\n  }, {\n    key: 'setRefreshToken',\n    value: function setRefreshToken(refreshToken) {\n      this.refreshToken = refreshToken;\n    }\n\n    /*\n       Set the current access token used for this instance.\n     */\n  }, {\n    key: 'setAccessToken',\n    value: function setAccessToken(accessToken) {\n      this.accessToken = accessToken;\n    }\n  }, {\n    key: 'getAuthorizationHeader',\n    value: function getAuthorizationHeader() {\n      return this.tokenType + ' ' + this.accessToken;\n    }\n\n    /*\n       Can we refresh our access token without user intervention?\n     */\n  }, {\n    key: 'canRefreshAccessToken',\n    value: function canRefreshAccessToken() {\n      return this._userConfig.oauth.type === 'script' || this._userConfig.oauth.type === 'explicit' && this._userConfig.oauth.duration === 'permanent' && this.hasRefreshToken();\n    }\n\n    /*\n       Get the Explicit Auth Url.\n     */\n  }, {\n    key: 'getExplicitAuthUrl',\n    value: function getExplicitAuthUrl(state) {\n\n      var query = {};\n\n      query.client_id = this._userConfig.oauth.key;\n      query.state = u.thisOrThat(state, Math.ceil(Math.random() * 1000));\n      query.redirect_uri = this._userConfig.oauth.redirectUri;\n      query.duration = this._userConfig.oauth.duration;\n      query.response_type = 'code';\n      query.scope = this.scope;\n\n      var baseUrl = 'https://' + this._userConfig.serverWWW + '/api/v1/authorize';\n\n      if (this._userConfig.mobile) {\n        baseUrl += '.compact';\n      }\n\n      return baseUrl + '?' + _querystring2['default'].stringify(query);\n    }\n\n    /*\n       Get the Implicit Auth Url.\n     */\n  }, {\n    key: 'getImplicitAuthUrl',\n    value: function getImplicitAuthUrl(state) {\n\n      var query = {};\n\n      query.client_id = this._userConfig.oauth.key;\n      query.state = u.thisOrThat(state, Math.ceil(Math.random() * 1000));\n      query.redirect_uri = this._userConfig.oauth.redirectUri;\n      query.response_type = 'token';\n      query.scope = this.scope;\n\n      var baseUrl = 'https://' + this._userConfig.serverWWW + '/api/v1/authorize';\n\n      if (this._userConfig.mobile) {\n        baseUrl += '.compact';\n      }\n\n      return baseUrl + '?' + _querystring2['default'].stringify(query);\n    }\n  }, {\n    key: 'getAuthUrl',\n    value: function getAuthUrl(state) {\n      switch (this._userConfig.oauth.type) {\n        case TOKEN.EXPLICIT:\n          return this.getExplicitAuthUrl(state);\n        case TOKEN.IMPLICIT:\n          return this.getImplicitAuthUrl(state);\n        default:\n          throw new Error('The oauth type of ' + oauthType + ' does not require an url');\n      }\n    }\n\n    /*\n       Returns the data needed to request an Applicaton Only\n       OAuth access token.\n     */\n  }, {\n    key: 'getAppOnlyTokenData',\n    value: function getAppOnlyTokenData() {\n      var params = {};\n\n      params.scope = this.scope;\n\n      // From the reddit documentation:\n      //\n      // - - -\n      // \"client_credentials\"\n      //\n      // Confidential clients (web apps / scripts) not acting on\n      // behalf of one or more logged out users.\n      //\n      // - - -\n      // \"https://oauth.reddit.com/grants/installed_client\"\n      //\n      // * Installed app types (as these apps are considered\n      // \"non-confidential\", have no secret, and thus, are\n      // ineligible for client_credentials grant.\n      //\n      // * Other apps acting on behalf of one or more \"logged out\" users.\n      //\n      switch (this._userConfig.oauth.type) {\n        case TOKEN.SCRIPT:\n        case TOKEN.EXPLICIT:\n          params.grant_type = 'client_credentials';\n          break;\n        // Also covers case TOKEN.IMPLICIT:\n        default:\n          params.grant_type = 'https://oauth.reddit.com/grants/installed_client';\n          params.device_id = this._userConfig.oauth.deviceId;\n      }\n\n      return params;\n    }\n\n    /*\n       Returns the data needed to request an authenticated OAuth\n       access token.\n     */\n  }, {\n    key: 'getAuthenticatedTokenData',\n    value: function getAuthenticatedTokenData(authorizationCode) {\n      var params = {};\n\n      params.scope = this.scope;\n\n      switch (this._userConfig.oauth.type) {\n        case TOKEN.SCRIPT:\n          params.grant_type = 'password';\n          params.username = this._userConfig.oauth.username;\n          params.password = this._userConfig.oauth.password;\n          break;\n        case TOKEN.EXPLICIT:\n          params.grant_type = 'authorization_code';\n          params.client_id = this._userConfig.oauth.key;\n          params.redirect_uri = this._userConfig.oauth.redirectUri;\n          params.code = authorizationCode;\n          break;\n        default:\n          return _when2['default'].reject(new Error('Invalid OAuth type specified (Authenticated OAuth).'));\n      }\n\n      return params;\n    }\n\n    /*\n       Returns the data needed to request a refresh token.\n     */\n  }, {\n    key: 'getRefreshTokenData',\n    value: function getRefreshTokenData(refreshToken) {\n      var params = {};\n      params.scope = this.scope;\n      params.grant_type = 'refresh_token';\n      params.refresh_token = refreshToken;\n      return params;\n    }\n\n    /*\n       A method that sets up a call to receive an access/refresh token.\n     */\n  }, {\n    key: 'getToken',\n    value: function getToken(tokenEnum) {\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n      var params = undefined;\n\n      switch (tokenEnum) {\n        case TOKEN.REFRESH:\n          params = this.getRefreshTokenData(options.refreshToken);\n          break;\n        case TOKEN.APP_ONLY:\n          params = this.getAppOnlyTokenData();\n          break;\n        case TOKEN.SCRIPT:\n        case TOKEN.EXPLICIT:\n          params = this.getAuthenticatedTokenData(options.authorizationCode);\n          break;\n      }\n\n      var headers = {};\n      var buff = new Buffer(this._userConfig.oauth.key + ':' + this._userConfig.oauth.secret);\n      var base64 = buff.toString('base64');\n      var auth = 'Basic ' + base64;\n\n      headers['Authorization'] = auth;\n\n      var endpoint = new _Endpoint2['default'](this._userConfig, this._userConfig.serverWWW, 'post', '/api/v1/access_token', headers, params, {}, this._userConfig.serverWWWPort);\n\n      var responseErrorHandler = function responseErrorHandler(response, endpoint) {\n        if (String(response._status).indexOf('4') === 0) {\n          return _when2['default'].reject(new _ResponseError2['default']('Invalid getToken request', response, endpoint));\n        }\n        // else return the endpoint to try again\n        return _when2['default'].resolve(endpoint);\n      };\n\n      return this._request.https(endpoint, responseErrorHandler).then(function (res) {\n        return JSON.parse(res._body);\n      });\n    }\n\n    /*\n       Sets the auth data from the oauth module to allow OAuth calls.\n        This method can authenticate with:\n        - Script based OAuth (no parameter)\n       - Raw authentication data\n       - Authorization Code (request_type = \"code\")\n       - Access Token (request_type = \"token\") / Implicit OAuth\n       - Application Only. (void 0, true);\n     */\n  }, {\n    key: 'auth',\n    value: function auth(authCodeOrAccessToken, isApplicationOnly) {\n      var _this = this;\n\n      var tokenData = undefined;\n\n      if (isApplicationOnly) {\n        tokenData = this.getToken(TOKEN.APP_ONLY);\n      } else {\n\n        var token = this._userConfig.oauth.type;\n\n        switch (token) {\n          case TOKEN.SCRIPT:\n            tokenData = this.getToken(token);\n            break;\n\n          case TOKEN.EXPLICIT:\n            // auth code in this case\n            tokenData = this.getToken(token, {\n              authorizationCode: authCodeOrAccessToken\n            });\n            break;\n\n          case TOKEN.IMPLICIT:\n            // access token in this case\n            tokenData = {\n              access_token: authCodeOrAccessToken,\n              token_type: 'bearer',\n              expires_in: 3600,\n              scope: this._userConfig.oauth.scope\n            };\n            break;\n\n          default:\n            throw new Error('Setting the auth data is no longer supported.');\n        }\n      }\n\n      return (0, _when2['default'])(tokenData).then(function (data) {\n\n        if (typeof data !== 'object') {\n          var str = String(data);\n          return _when2['default'].reject(new Error('There was a problem authenticating:\\n' + str));\n        }\n\n        _this.accessToken = data.access_token;\n        _this.tokenType = data.token_type;\n\n        // If the explicit app used a perminant duration, send\n        // back the refresh token that will be used to re-authenticate\n        // later without user interaction.\n        if (data.refresh_token) {\n          // set the internal refresh token for automatic expiring\n          // access_token management\n          _this.refreshToken = data.refresh_token;\n          return _this.refreshToken;\n        }\n      });\n    }\n\n    /*\n       Only authenticates with Application Only OAuth\n     */\n  }, {\n    key: 'applicationOnlyAuth',\n    value: function applicationOnlyAuth() {\n      return this.auth(void 0, true);\n    }\n\n    /*\n       Authenticate with a refresh token.\n     */\n  }, {\n    key: 'refresh',\n    value: function refresh(refreshToken) {\n      var _this2 = this;\n\n      // use the provided refresh token, or the current\n      // one that we have for this class\n      refreshToken = u.thisOrThat(refreshToken, this.refreshToken);\n\n      return this.getToken(TOKEN.REFRESH, {\n        refreshToken: refreshToken\n      }).then(function (data) {\n        // only set the internal refresh token if reddit\n        // agrees that it was OK and sends back authData\n        _this2.refreshToken = refreshToken;\n\n        _this2.accessToken = data.access_token;\n        _this2.tokenType = data.token_type;\n\n        _this2.emit('access_token_refreshed', _this2.accessToken);\n      });\n    }\n\n    /*\n       Clears any authentication data & removes OAuth authentication\n        By default it will only remove the \"access_token\". Specify\n       the users refresh token to revoke that token instead.\n     */\n  }, {\n    key: 'deauth',\n    value: function deauth(refreshToken) {\n      var _this3 = this;\n\n      // no need to deauth if not authenticated\n      if (!this.hasAccessToken()) {\n        return _when2['default'].resolve();\n      }\n\n      var isRefreshToken = typeof refreshToken === 'string';\n\n      var token = isRefreshToken ? refreshToken : this.accessToken;\n\n      var tokenTypeHint = isRefreshToken ? 'refresh_token' : 'access_token';\n\n      var params = {\n        token: token,\n        token_type_hint: tokenTypeHint\n      };\n\n      var auth = 'Basic ' + new Buffer(this._userConfig.oauth.key + ':' + this._userConfig.oauth.secret).toString('base64');\n\n      var headers = {\n        'Authorization': auth\n      };\n\n      var endpoint = new _Endpoint2['default'](this._userConfig, this._userConfig.serverWWW, 'post', '/api/v1/revoke_token', headers, params, {}, this._userConfig.serverWWWPort);\n\n      return this._request.https(endpoint).then(function (response) {\n        // If we did not get back a 204 this then it did not sucessfully\n        // revoke the token\n        if (response._status !== 204) {\n          return _when2['default'].reject(new Error('Unable to revoke the given token'));\n        }\n\n        // clear the data for this OAuth object\n        _this3.accessToken = TOKEN.INVALID;\n        _this3.tokenType = TOKEN.INVALID;\n\n        // only clear the refresh token if one was provided\n        if (isRefreshToken) {\n          _this3.refreshToken = TOKEN.INVALID;\n        }\n      });\n    }\n  }]);\n\n  return OAuth;\n})(_events2['default'].EventEmitter);\n\nexports['default'] = OAuth;\n//# sourceMappingURL=OAuth.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/Modhash.js":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _when = require('when');\n\nvar _when2 = _interopRequireDefault(_when);\n\nvar _utils = require('./utils');\n\nvar u = _interopRequireWildcard(_utils);\n\nvar _Endpoint = require('./Endpoint');\n\nvar _Endpoint2 = _interopRequireDefault(_Endpoint);\n\nvar _ResponseError = require('./ResponseError');\n\nvar _ResponseError2 = _interopRequireDefault(_ResponseError);\n\nvar Modhash = (function (_events$EventEmitter) {\n  _inherits(Modhash, _events$EventEmitter);\n\n  function Modhash(userConfig, request) {\n    _classCallCheck(this, Modhash);\n\n    _get(Object.getPrototypeOf(Modhash.prototype), 'constructor', this).call(this);\n\n    this._userConfig = userConfig;\n\n    this._request = request;\n\n    this.modhash = '';\n    this.modhashRefreshed = 0;\n  }\n\n  _createClass(Modhash, [{\n    key: 'isModhashOld',\n    value: function isModhashOld() {\n      // 10 minutes by default\n      var timeout = 10 * 60 * 1000;\n\n      return Date.now() - this.modhashRefreshed > timeout;\n    }\n  }, {\n    key: 'setModhash',\n    value: function setModhash(modhash) {\n      this.modhash = modhash;\n      this.modhashRefreshed = Date.now();\n    }\n  }, {\n    key: 'hasModhash',\n    value: function hasModhash() {\n      return !!this.modhash.length;\n    }\n\n    /*\n       Get the current cached modhash.\n     */\n  }, {\n    key: 'getCurrentModhash',\n    value: function getCurrentModhash() {\n      if (!this.hasModhash()) {\n        return undefined;\n      }\n      return this.modhash;\n    }\n  }, {\n    key: 'refreshModhash',\n    value: function refreshModhash() {\n      var _this = this;\n\n      var endpoint = new _Endpoint2['default'](this._userConfig, this._userConfig.serverWWW, 'get', '/api/me.json', {}, {}, {}, this._userConfig.serverWWWPort);\n\n      var responseErrorHandler = function responseErrorHandler(response, endpoint) {\n        if (String(response._status).indexOf('4') === 0) {\n          return _when2['default'].reject(new _ResponseError2['default']('Invalid refreshModhash request', response, endpoint));\n        }\n        // else return the endpoint to try again\n        return _when2['default'].resolve(endpoint);\n      };\n\n      return this._request.https(endpoint, responseErrorHandler).then(function (res) {\n        var response = JSON.parse(res._body);\n\n        if (!response.data) {\n          throw new _ResponseError2['default']('Invalid refreshModhash response. Are you logged in?', response, endpoint);\n        } else {\n          _this.setModhash(response.data.modhash);\n\n          return {\n            modhash: response.data.modhash\n          };\n        }\n      });\n    }\n  }, {\n    key: 'getModhash',\n    value: function getModhash() {\n      if (!this.isModhashOld()) {\n        return _when2['default'].resolve({\n          modhash: this.modhash\n        });\n      } else {\n        return this.refreshModhash();\n      }\n    }\n  }]);\n\n  return Modhash;\n})(_events2['default'].EventEmitter);\n\nexports['default'] = Modhash;\nmodule.exports = exports['default'];\n//# sourceMappingURL=Modhash.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/build/src/https/file.js":"/*\nRepresents a file that we wish to upload to reddit.\n\nAll files have a name, mimeType, and data. \n\nIn the browser data can be a `File` object directly from\na file input, or a `Blob` object.\n\nIn node, data can be a `utf8` string, or a buffer\ncontaining the content of the file.\n*/\n\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nexports['default'] = function (name, mimeType, data) {\n  var self = {};\n\n  self.name = name;\n  self.mimeType = mimeType;\n\n  if (typeof File !== 'undefined' && data instanceof File || typeof Blob !== 'undefined' && data instanceof Blob) {\n    self.data = data;\n  } else {\n    self.data = typeof data === 'string' ? new Buffer(data) : data;\n  }\n\n  return self;\n};\n\nmodule.exports = exports['default'];\n//# sourceMappingURL=file.js.map\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/gulpfile.js":"var fs = require('fs');\nvar path = require('path');\nvar exec = require('child_process').exec;\nvar spawn = require('child_process').spawn;\n\nvar gulp = require('gulp');\nvar gutil = require('gulp-util');\nvar sourcemaps = require('gulp-sourcemaps');\nvar uglify = require('gulp-uglify');\nvar babel = require('gulp-babel');\n\nvar source = require('vinyl-source-stream');\nvar buffer = require('vinyl-buffer');\nvar browserify = require('browserify');\n\ngulp.task('copyTestConfig', function(done) {\n  var configPath = path.join(__dirname, 'test', 'config.js');\n  var configTemplatePath = configPath + '.template';\n\n  fs.exists(configPath, function(exists) {\n    if (exists) {\n      return done();\n    }\n\n    fs.createReadStream(configTemplatePath)\n      .pipe(fs.createWriteStream(configPath))\n      .on('finish', done);\n  });\n});\n\ngulp.task('babel', function() {\n  return gulp.src('./src/**/*.js')\n             .pipe(sourcemaps.init())\n             .pipe(babel())\n             .pipe(sourcemaps.write('./'))\n             .pipe(gulp.dest('./build/src/'));\n});\n\ngulp.task('babelTests', [ 'copyTestConfig' ], function() {\n  return gulp.src('./test/**/*.js')\n             .pipe(sourcemaps.init())\n             .pipe(babel())\n             .pipe(sourcemaps.write('./'))\n             .pipe(gulp.dest('./build/test/'));\n});\n\ngulp.task('bundleBrowser', [ 'babel' ], function() {\n  // set up the browserify instance on a task basis\n  var b = browserify({\n    entries: './build/src/Snoocore.js',\n    // exclude: [ './build/src/https/httpsNode.js' ],\n    standalone: 'Snoocore',\n    debug: true\n  });\n\n  return b.bundle()\n          .pipe(source('Snoocore-browser.min.js'))\n          .pipe(buffer())\n          .pipe(sourcemaps.init())\n          .pipe(uglify())\n          .on('error', gutil.log)\n          .pipe(sourcemaps.write('./'))\n          .pipe(gulp.dest('./dist/'));\n});\n\ngulp.task('bundleBrowserTests', [ 'babelTests' ], function() {\n  // set up the browserify instance on a task basis\n  var b = browserify({\n    entries: './build/test/browser-tests.js',\n    standalone: 'SnoocoreTests',\n    debug: true\n  });\n\n  return b.bundle()\n          .pipe(source('browser-tests.js'))\n          .pipe(buffer())\n          .pipe(sourcemaps.init())\n          .on('error', gutil.log)\n          .pipe(sourcemaps.write('./'))\n          .pipe(gulp.dest('./build/test/'));\n});\n\ngulp.task('buildNode', [ 'babel', 'babelTests' ]);\n\ngulp.task('mocha', [ 'buildNode' ], function(done) {\n  var mocha = spawn(\n    path.join(__dirname, 'node_modules', '.bin', 'mocha'),\n    [\n      '-R', 'spec',\n      'build/test/node-tests.js'\n    ],\n    { cwd: __dirname, stdio: 'inherit' }\n  );\n\n  mocha.on('exit', function(code) {\n    return (code !== 0)\n      ? done(new Error('Mocha tests failed to run'))\n      : done();\n  });\n});\n\ngulp.task('buildBrowser', [ 'bundleBrowser', 'bundleBrowserTests' ]);\n\ngulp.task('karma', [ 'buildBrowser' ], function(done) {\n  var karma = spawn(\n    path.join(__dirname, 'node_modules', 'karma', 'bin', 'karma'),\n    [ 'start', 'build/test/karma.conf.js'  ],\n    { cwd: __dirname, stdio: 'inherit' }\n  );\n\n  karma.on('exit', function(code) {\n    return (code !== 0)\n      ? done(new Error('Karma tests failed to run'))\n      : done();\n  });\n});\n\n// The default task (called when you run `gulp` from cli)\ngulp.task('default', function(done) {\n  console.error('no default task!');\n  done();\n});\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/Endpoint.js":"import urlLib from 'url';\n\nimport * as u from './utils';\n\nexport default class Endpoint {\n\n  constructor(userConfig,\n              hostname, method, path, headers={},\n              givenArgs={}, givenContextOptions={}, port=80)\n  {\n    this._userConfig = userConfig;\n\n    this.hostname = hostname;\n    this.port = port;\n    this.method = method;\n    this.path = path;\n    this.headers = headers;\n\n    this.contextOptions = this.normalizeContextOptions(givenContextOptions);\n\n    this.givenArgs = givenArgs;\n    this.args = this.buildArgs();\n    this.url = this.buildUrl();\n    this.computedPath = urlLib.parse(this.url).path;\n  }\n\n  setHeaders(headers) {\n    this.headers = headers;\n  }\n\n  /*\n     Returns a set of options that effect how each call to reddit behaves.\n   */\n  normalizeContextOptions(givenContextOptions) {\n\n    let cOptions = givenContextOptions || {};\n\n    // by default we do not bypass authentication\n    cOptions.bypassAuth = u.thisOrThat(cOptions.bypassAuth, false);\n\n    // decode html enntities for this call?\n    cOptions.decodeHtmlEntities = u.thisOrThat(cOptions.decodeHtmlEntities,\n                                               this._userConfig.decodeHtmlEntities);\n\n    // how many attempts left do we have to retry an endpoint?\n\n    // use the given retryAttemptsLeft, or the retryAttempts passed in the\n    // context options if not specified\n    cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft,\n                                              cOptions.retryAttempts);\n\n    // use the given retryAttemptsLeft, or the retryAttempts passed in the\n    // user configuration\n    cOptions.retryAttemptsLeft = u.thisOrThat(cOptions.retryAttemptsLeft,\n                                              this._userConfig.retryAttempts);\n\n    // delay between retrying an endpoint\n    cOptions.retryDelay = u.thisOrThat(cOptions.retryDelay,\n                                       this._userConfig.retryDelay);\n\n    // milliseconds before a request times out\n    cOptions.requestTimeout = u.thisOrThat(cOptions.requestTimeout,\n                                           this._userConfig.requestTimeout);\n\n    // how many reauthentication attempts do we have left?\n    cOptions.reauthAttemptsLeft = u.thisOrThat(cOptions.reauthAttemptsLeft,\n                                               cOptions.retryAttemptsLeft);\n\n    return cOptions;\n  }\n\n  /*\n     Build the arguments that we will send to reddit in our\n     request. These customize the request that we send to reddit\n   */\n  buildArgs() {\n    let args = {};\n\n    // Skip any url parameters (e.g. items that begin with $)\n    for (let key in this.givenArgs) {\n      if (key.substring(0, 1) !== '$') {\n        args[key] = this.givenArgs[key];\n      }\n    }\n\n    let apiType = u.thisOrThat(this.contextOptions.api_type,\n                               this._userConfig.apiType);\n\n    if (apiType) {\n      args.api_type = apiType;\n    }\n\n    return args;\n  }\n\n  /*\n     Builds the URL that we will query reddit with.\n   */\n  buildUrl() {\n    let url = this.hostname;\n\n    if (this.port !== 80) {\n      url += ':' + this.port;\n    }\n\n    let path = this.path;\n    if (path.substring(0, 1) !== '/') {\n      path = '/' + path;\n    }\n\n    url += path;\n\n    url = replaceUrlParams(url, this.givenArgs);\n    url = url.replace('//', '/');\n    url = 'https://' + url;\n    return url;\n  }\n\n}\n\n\n/*\n   Takes an url, and an object of url parameters and replaces\n   them, e.g.\n\n   endpointUrl:\n   'http://example.com/$foo/$bar/test.html'\n\n   this.givenArgs: { $foo: 'hello', $bar: 'world' }\n\n   would output:\n\n   'http://example.com/hello/world/test.html'\n */\nexport function replaceUrlParams(endpointUrl, givenArgs) {\n  // nothing to replace!\n  if (endpointUrl.indexOf('$') === -1) {\n    return endpointUrl;\n  }\n\n  // pull out variables from the url\n  let params = endpointUrl.match(/\\$[\\w\\.]+/g);\n\n  // replace with the argument provided\n  params.forEach(param => {\n    if (typeof givenArgs[param] === 'undefined') {\n      throw new Error('missing required url parameter ' + param);\n    }\n    endpointUrl = endpointUrl.replace(param, givenArgs[param]);\n  });\n\n  return endpointUrl;\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/Modhash.js":"import events from 'events';\n\nimport when from 'when';\n\nimport * as u from './utils';\n\nimport Endpoint from './Endpoint';\nimport ResponseError from './ResponseError';\n\nexport default class Modhash extends events.EventEmitter {\n\n  constructor(userConfig, request) {\n    super();\n\n    this._userConfig = userConfig;\n\n    this._request = request;\n\n    this.modhash = '';\n    this.modhashRefreshed = 0;\n  }\n\n  isModhashOld() {\n    // 10 minutes by default\n    let timeout = 10 * 60 * 1000;\n\n    return (Date.now() - this.modhashRefreshed) > timeout;\n  }\n\n  setModhash(modhash) {\n    this.modhash = modhash;\n    this.modhashRefreshed = Date.now();\n  }\n\n  hasModhash() {\n    return !!this.modhash.length;\n  }\n\n  /*\n     Get the current cached modhash.\n   */\n  getCurrentModhash() {\n    if (!this.hasModhash()) {\n      return undefined;\n    }\n    return this.modhash;\n  }\n\n  refreshModhash() {\n    let endpoint = new Endpoint(this._userConfig,\n                                this._userConfig.serverWWW,\n                                'get',\n                                '/api/me.json',\n                                {},\n                                {},\n                                {},\n                                this._userConfig.serverWWWPort);\n\n    let responseErrorHandler = (response, endpoint) => {\n      if (String(response._status).indexOf('4') === 0) {\n        return when.reject(new ResponseError(\n          'Invalid refreshModhash request', response, endpoint));\n      }\n      // else return the endpoint to try again\n      return when.resolve(endpoint);\n    };\n    \n    return this._request.https(endpoint, responseErrorHandler).then(res => {\n      let response = JSON.parse(res._body);\n\n      if (!response.data) {\n        throw new ResponseError(\n          'Invalid refreshModhash response. Are you logged in?', response, endpoint);\n      } else {\n        this.setModhash(response.data.modhash);\n\n        return {\n          modhash: response.data.modhash\n        };\n      }\n    });\n  }\n\n  getModhash() {\n    if (!this.isModhashOld()) {\n      return when.resolve({\n        modhash: this.modhash\n      });\n    } else {\n      return this.refreshModhash();\n    }\n  }\n}","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/OAuth.js":"import events from 'events';\nimport querystring from 'querystring';\nimport util from 'util';\nimport urlLib from 'url';\n\nimport when from 'when';\n\nimport * as u from './utils';\n\nimport Endpoint from './Endpoint';\nimport ResponseError from './ResponseError';\n\n/*\n   Various OAuth types\n */\nexport const TOKEN = {\n  EXPLICIT: 'explicit',\n  IMPLICIT: 'implicit',\n  SCRIPT: 'script',\n  APP_ONLY: 'app_only',\n  REFRESH: 'refresh',\n  INVALID: 'invalid_token' // Represents an unset/invalid token\n};\n\n/*\n   Represents a single OAuth instance. Used primarily for internal\n   use within the Snoocore class to manage two OAuth instances -\n   Applicaton Only and an Authenticated Session.\n\n */\nexport default class OAuth extends events.EventEmitter {\n\n  constructor(userConfig, request) {\n    super();\n\n    this._userConfig = userConfig;\n\n    this._request = request;\n\n    this.accessToken = TOKEN.INVALID;\n    this.refreshToken = TOKEN.INVALID;\n    this.tokenType = 'bearer';\n\n    this.scope = this.normalizeScope();\n  }\n\n  /*\n     Takes a given scope, and normalizes it to a proper string.\n   */\n  normalizeScope() {\n    let scope;\n    // Set to empty string if the scope if not set\n    if (typeof this._userConfig.oauth.scope === 'undefined') {\n      scope = '';\n    }\n    // convert an array into a string\n    else if (util.isArray(this._userConfig.oauth.scope)) {\n      scope = this._userConfig.oauth.scope.join(',');\n    }\n    return scope;\n  }\n\n  /*\n     Do we have a refresh token defined?\n   */\n  hasRefreshToken() {\n    return this.refreshToken !== TOKEN.INVALID;\n  }\n\n  /*\n     Do we have an access token defined?\n   */\n  hasAccessToken() {\n    return this.accessToken !== TOKEN.INVALID;\n  }\n\n  /*\n     Get the current refresh token used for this instance.\n   */\n  getRefreshToken() {\n    if (this.refreshToken === TOKEN.INVALID) {\n      return undefined;\n    }\n    return this.refreshToken;\n  }\n\n  /*\n     Get the current access token used for this instance.\n   */\n  getAccessToken() {\n    if (this.accessToken === TOKEN.INVALID) {\n      return undefined;\n    }\n    return this.accessToken;\n  }\n\n  /*\n     Set the current refresh token used for this instance.\n   */\n  setRefreshToken(refreshToken) {\n    this.refreshToken = refreshToken;\n  }\n\n  /*\n     Set the current access token used for this instance.\n   */\n  setAccessToken(accessToken) {\n    this.accessToken = accessToken;\n  }\n\n  getAuthorizationHeader() {\n    return `${this.tokenType} ${this.accessToken}`;\n  }\n\n  /*\n     Can we refresh our access token without user intervention?\n   */\n  canRefreshAccessToken() {\n    return (this._userConfig.oauth.type === 'script') ||\n           (this._userConfig.oauth.type === 'explicit' &&\n             this._userConfig.oauth.duration === 'permanent' &&\n             this.hasRefreshToken());\n  }\n\n  /*\n     Get the Explicit Auth Url.\n   */\n  getExplicitAuthUrl(state) {\n\n    let query = {};\n\n    query.client_id = this._userConfig.oauth.key;\n    query.state = u.thisOrThat(state, Math.ceil(Math.random() * 1000));\n    query.redirect_uri = this._userConfig.oauth.redirectUri;\n    query.duration = this._userConfig.oauth.duration;\n    query.response_type = 'code';\n    query.scope = this.scope;\n\n    let baseUrl = `https://${this._userConfig.serverWWW}/api/v1/authorize`;\n\n    if (this._userConfig.mobile) {\n      baseUrl += '.compact';\n    }\n\n    return baseUrl + '?' + querystring.stringify(query);\n  }\n\n  /*\n     Get the Implicit Auth Url.\n   */\n  getImplicitAuthUrl(state) {\n\n    let query = {};\n\n    query.client_id = this._userConfig.oauth.key;\n    query.state = u.thisOrThat(state, Math.ceil(Math.random() * 1000));\n    query.redirect_uri = this._userConfig.oauth.redirectUri;\n    query.response_type = 'token';\n    query.scope = this.scope;\n\n    let baseUrl = `https://${this._userConfig.serverWWW}/api/v1/authorize`;\n\n    if (this._userConfig.mobile) {\n      baseUrl += '.compact';\n    }\n\n    return baseUrl + '?' + querystring.stringify(query);\n  }\n\n  getAuthUrl(state) {\n    switch(this._userConfig.oauth.type) {\n      case TOKEN.EXPLICIT:\n        return this.getExplicitAuthUrl(state);\n      case TOKEN.IMPLICIT:\n        return this.getImplicitAuthUrl(state);\n      default:\n        throw new Error(\n          `The oauth type of ${oauthType} does not require an url`);\n    }\n  }\n\n  /*\n     Returns the data needed to request an Applicaton Only\n     OAuth access token.\n   */\n  getAppOnlyTokenData() {\n    let params = {};\n\n    params.scope = this.scope;\n\n    // From the reddit documentation:\n    //\n    // - - -\n    // \"client_credentials\"\n    //\n    // Confidential clients (web apps / scripts) not acting on\n    // behalf of one or more logged out users.\n    //\n    // - - -\n    // \"https://oauth.reddit.com/grants/installed_client\"\n    //\n    // * Installed app types (as these apps are considered\n    // \"non-confidential\", have no secret, and thus, are\n    // ineligible for client_credentials grant.\n    //\n    // * Other apps acting on behalf of one or more \"logged out\" users.\n    //\n    switch(this._userConfig.oauth.type) {\n      case TOKEN.SCRIPT:\n      case TOKEN.EXPLICIT:\n        params.grant_type = 'client_credentials';\n        break;\n        // Also covers case TOKEN.IMPLICIT:\n      default:\n        params.grant_type = 'https://oauth.reddit.com/grants/installed_client';\n        params.device_id = this._userConfig.oauth.deviceId;\n    }\n\n    return params;\n  }\n\n  /*\n     Returns the data needed to request an authenticated OAuth\n     access token.\n   */\n  getAuthenticatedTokenData(authorizationCode) {\n    let params = {};\n\n    params.scope = this.scope;\n\n    switch (this._userConfig.oauth.type) {\n      case TOKEN.SCRIPT:\n        params.grant_type = 'password';\n        params.username = this._userConfig.oauth.username;\n        params.password = this._userConfig.oauth.password;\n        break;\n      case TOKEN.EXPLICIT:\n        params.grant_type = 'authorization_code';\n        params.client_id = this._userConfig.oauth.key;\n        params.redirect_uri = this._userConfig.oauth.redirectUri;\n        params.code = authorizationCode;\n        break;\n      default:\n        return when.reject(new Error(\n          'Invalid OAuth type specified (Authenticated OAuth).'));\n    }\n\n    return params;\n  }\n\n  /*\n     Returns the data needed to request a refresh token.\n   */\n  getRefreshTokenData(refreshToken) {\n    let params = {};\n    params.scope = this.scope;\n    params.grant_type = 'refresh_token';\n    params.refresh_token = refreshToken;\n    return params;\n  }\n\n  /*\n     A method that sets up a call to receive an access/refresh token.\n   */\n  getToken(tokenEnum, options={}) {\n\n    let params;\n\n    switch(tokenEnum) {\n      case TOKEN.REFRESH:\n        params = this.getRefreshTokenData(options.refreshToken);\n        break;\n      case TOKEN.APP_ONLY:\n        params = this.getAppOnlyTokenData();\n        break;\n      case TOKEN.SCRIPT:\n      case TOKEN.EXPLICIT:\n        params = this.getAuthenticatedTokenData(options.authorizationCode);\n        break;\n    }\n\n    let headers = {};\n    let buff = new Buffer(this._userConfig.oauth.key + ':' +\n                          this._userConfig.oauth.secret);\n    let base64 = (buff).toString('base64');\n    let auth = `Basic ${base64}`;\n\n    headers['Authorization'] = auth;\n\n    let endpoint = new Endpoint(this._userConfig,\n                                this._userConfig.serverWWW,\n                                'post',\n                                '/api/v1/access_token',\n                                headers,\n                                params,\n                                {},\n                                this._userConfig.serverWWWPort);\n\n    let responseErrorHandler = (response, endpoint) => {\n      if (String(response._status).indexOf('4') === 0) {\n        return when.reject(new ResponseError(\n          'Invalid getToken request', response, endpoint));\n      }\n      // else return the endpoint to try again\n      return when.resolve(endpoint);\n    };\n    \n    return this._request.https(endpoint, responseErrorHandler).then(res => {\n      return JSON.parse(res._body);\n    });\n  }\n\n  /*\n     Sets the auth data from the oauth module to allow OAuth calls.\n\n     This method can authenticate with:\n\n     - Script based OAuth (no parameter)\n     - Raw authentication data\n     - Authorization Code (request_type = \"code\")\n     - Access Token (request_type = \"token\") / Implicit OAuth\n     - Application Only. (void 0, true);\n   */\n  auth(authCodeOrAccessToken, isApplicationOnly) {\n    let tokenData;\n\n    if (isApplicationOnly) {\n      tokenData = this.getToken(TOKEN.APP_ONLY);\n    } else {\n\n      let token = this._userConfig.oauth.type;\n\n      switch(token) {\n        case TOKEN.SCRIPT:\n          tokenData = this.getToken(token);\n          break;\n\n        case TOKEN.EXPLICIT:\n          // auth code in this case\n          tokenData = this.getToken(token, {\n            authorizationCode: authCodeOrAccessToken\n          });\n          break;\n\n        case TOKEN.IMPLICIT:\n          // access token in this case\n          tokenData = {\n            access_token: authCodeOrAccessToken,\n            token_type: 'bearer',\n            expires_in: 3600,\n            scope: this._userConfig.oauth.scope\n          };\n          break;\n\n        default:\n          throw new Error('Setting the auth data is no longer supported.');\n      }\n    }\n\n    return when(tokenData).then(data => {\n\n      if (typeof data !== 'object') {\n        let str = String(data);\n        return when.reject(new Error(\n          `There was a problem authenticating:\\n${str}`));\n      }\n\n      this.accessToken = data.access_token;\n      this.tokenType = data.token_type;\n\n      // If the explicit app used a perminant duration, send\n      // back the refresh token that will be used to re-authenticate\n      // later without user interaction.\n      if (data.refresh_token) {\n        // set the internal refresh token for automatic expiring\n        // access_token management\n        this.refreshToken = data.refresh_token;\n        return this.refreshToken;\n      }\n    });\n  }\n\n  /*\n     Only authenticates with Application Only OAuth\n   */\n  applicationOnlyAuth() {\n    return this.auth(void 0, true);\n  }\n\n  /*\n     Authenticate with a refresh token.\n   */\n  refresh(refreshToken) {\n\n    // use the provided refresh token, or the current\n    // one that we have for this class\n    refreshToken = u.thisOrThat(refreshToken, this.refreshToken);\n\n    return this.getToken(TOKEN.REFRESH, {\n      refreshToken: refreshToken\n    }).then(data => {\n      // only set the internal refresh token if reddit\n      // agrees that it was OK and sends back authData\n      this.refreshToken = refreshToken;\n\n      this.accessToken = data.access_token;\n      this.tokenType = data.token_type;\n\n      this.emit('access_token_refreshed', this.accessToken);\n    });\n  }\n\n  /*\n     Clears any authentication data & removes OAuth authentication\n\n     By default it will only remove the \"access_token\". Specify\n     the users refresh token to revoke that token instead.\n   */\n  deauth(refreshToken) {\n\n    // no need to deauth if not authenticated\n    if (!this.hasAccessToken()) {\n      return when.resolve();\n    }\n\n    let isRefreshToken = typeof refreshToken === 'string';\n\n    let token = isRefreshToken ? refreshToken : this.accessToken;\n\n    let tokenTypeHint = isRefreshToken ? 'refresh_token' : 'access_token';\n\n    let params = {\n      token: token,\n      token_type_hint: tokenTypeHint\n    };\n\n    let auth = 'Basic ' + (new Buffer(\n      this._userConfig.oauth.key + ':' +\n      this._userConfig.oauth.secret)).toString('base64');\n\n    let headers = {\n      'Authorization': auth\n    };\n\n    let endpoint = new Endpoint(this._userConfig,\n                                this._userConfig.serverWWW,\n                                'post',\n                                '/api/v1/revoke_token',\n                                headers,\n                                params,\n                                {},\n                                this._userConfig.serverWWWPort);\n\n    return this._request.https(endpoint).then(response => {\n      // If we did not get back a 204 this then it did not sucessfully\n      // revoke the token\n      if (response._status !== 204) {\n        return when.reject(new Error('Unable to revoke the given token'));\n      }\n\n      // clear the data for this OAuth object\n      this.accessToken = TOKEN.INVALID;\n      this.tokenType = TOKEN.INVALID;\n\n      // only clear the refresh token if one was provided\n      if (isRefreshToken) {\n        this.refreshToken = TOKEN.INVALID;\n      }\n    });\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/RedditRequest.js":"\n// node modules\nimport util from 'util';\nimport events from 'events';\nimport urlLib from 'url';\n\n// npm modules\nimport when from 'when';\nimport delay from 'when/delay';\nimport he from 'he';\n\n// our modules\nimport Request from './Request';\nimport Endpoint from './Endpoint';\nimport ResponseError from './ResponseError';\n\n/*\n   A collection of functions that deal with requesting data from the\n   reddit API.\n */\nexport default class RedditRequest extends events.EventEmitter {\n\n  constructor(userConfig, request, oauth, oauthAppOnly, modhash) {\n    super();\n    this._request = request;\n    this._userConfig = userConfig;\n    this._oauth = oauth;\n    this._oauthAppOnly = oauthAppOnly;\n    this._modhash = modhash;\n  }\n\n  /*\n     Currently application only?\n\n     If we do not have an access token and there is no way\n     to get a new access token then yes! We are application\n     only oauth.\n   */\n  isApplicationOnly() {\n    return !this._oauth.hasAccessToken() && !this._oauth.canRefreshAccessToken();\n  }\n\n  /*\n     Are we currently authenticated?\n   */\n  isAuthenticated() {\n    return this.isApplicationOnly() ?\n           this._oauthAppOnly.hasAccessToken() :\n           this._oauth.hasAccessToken();\n  }\n\n  /*\n     Builds up the headers for an endpoint.\n   */\n  buildHeaders(contextOptions={}) {\n    let headers = {};\n\n    if (this._userConfig.isNode) {\n      // Can't set User-Agent in browser\n      headers['User-Agent'] = this._userConfig.userAgent;\n    }\n\n    if (this._userConfig.useBrowserCookies) {\n      headers['X-User-Agent'] = this._userConfig.userAgent;\n\n      if (this._modhash.hasModhash() && !this._modhash.isModhashOld()) {\n        headers['X-Modhash'] = this._modhash.getCurrentModhash();\n      }\n    }\n\n    if (!this._userConfig.useBrowserCookies) {\n      if (contextOptions.bypassAuth || this.isApplicationOnly()) {\n        headers['Authorization'] = this._oauthAppOnly.getAuthorizationHeader();\n      } else {\n        headers['Authorization'] = this._oauth.getAuthorizationHeader();\n      }\n    }\n\n    return headers;\n  }\n\n  /*\n     Call the reddit api.\n   */\n  callRedditApi(endpoint) {\n    // Authenticate if needed before making a call.\n    //\n    // Eliminates unwanted 401 errors when making initial calls\n    // on Application only OAuth & Script instances where calling\n    // `.auth()` isn't required.\n    let auth = this.isAuthenticated() ? when.resolve() : (() => {\n      return this.authenticate(endpoint).then(() => {\n        // rebuild endpoint with new headers\n        endpoint = new Endpoint(this._userConfig,\n                                 endpoint.hostname,\n                                 endpoint.method,\n                                 endpoint.path,\n                                 this.buildHeaders(\n                                   endpoint.contextOptions),\n                                 endpoint.givenArgs,\n                                 endpoint.contextOptions,\n                                 endpoint.port);\n\n      });\n    })();\n\n    return auth.then(() => {\n      let requestPromise = this._request.https(\n        endpoint, this.responseErrorHandler.bind(this));\n\n      return requestPromise.then(response => {\n        return this.handleSuccessResponse(response, endpoint);\n      });\n    });\n  }\n\n  /*\n     Authenticate with the appropriate OAuth type for a given\n     endpoint\n   */\n  authenticate(endpoint) {\n    let authPromise;\n\n    // If we are application only, or are bypassing authentication\n    // therefore we're using application only OAuth\n    if (this._userConfig.useBrowserCookies) {\n      if (endpoint.method === 'post') {\n        authPromise = this._modhash.getModhash();\n      } else {\n        authPromise = when.resolve();\n      }\n    }\n    else if (this.isApplicationOnly() || endpoint.contextOptions.bypassAuth) {\n      authPromise = this._oauthAppOnly.applicationOnlyAuth();\n    }\n    else if (this._oauth.canRefreshAccessToken()) {\n      // If we have been authenticated with a permanent refresh token use it\n      if (this._oauth.hasRefreshToken()) {\n        authPromise = this._oauth.refresh();\n      }\n      // If we are OAuth type script we can call `.auth` again\n      else if (this._userConfig.isOAuthType('script')) {\n        authPromise = this._oauth.auth();\n      }\n    }\n    // No way to authenticate\n    else {\n      return when.reject(new Error('Unable to authenticate'));\n    }\n\n    return authPromise;\n  }\n\n  /*\n     Handle a request errors from reddit. This is usually caused when our\n     access_token has expired, or reddit servers are under heavy load.\n\n     If we can't renew our access token, we throw an error / emit the\n     'access_token_expired' event that users can then handle to\n     re-authenticatet clients\n\n     If we can renew our access token, we try to reauthenticate, and call the\n     reddit endpoint again.\n   */\n  responseErrorHandler(response, endpoint) {\n\n    // - - -\n    // Check headers for more specific errors.\n\n    let wwwAuth = response._headers['www-authenticate'];\n\n    if (wwwAuth && wwwAuth.indexOf('insufficient_scope') !== -1) {\n      return when.reject(new ResponseError(\n        'Insufficient scopes provided for this call',\n        response,\n        endpoint));\n    }\n\n    // - - -\n    // 404 - Page not found\n    if (response._status === 404) {\n      let msg = 'Page not found. Is this a valid endpoint?';\n      return when.reject(new ResponseError(msg, response, endpoint));\n    }\n\n    // - - -\n    // Access token has expired\n    if (response._status === 401 && !this._userConfig.useBrowserCookies) {\n\n      // Atempt to get a new access token!\n      let reauthPromise = this.authenticate(endpoint);\n\n      return reauthPromise.then(() => {\n        // refresh the authentication headers for this endpoint\n        endpoint.setHeaders(this.buildHeaders(endpoint.contextOptions));\n\n        let modifiedEndpoint = new Endpoint(this._userConfig,\n                                            endpoint.hostname,\n                                            endpoint.method,\n                                            endpoint.path,\n                                            this.buildHeaders(\n                                              endpoint.contextOptions),\n                                            endpoint.givenArgs,\n                                            endpoint.contextOptions,\n                                            endpoint.port);\n\n        return when.resolve(modifiedEndpoint);\n      }).catch(error => {\n        this.emit('access_token_expired');\n\n        let msg = 'Access token has expired. Listen for ' +\n                   'the \"access_token_expired\" event to ' +\n                     'handle this gracefully in your app.';\n        return when.reject(new ResponseError(msg, response, endpoint));\n      });\n    }\n\n    // - - -\n    // Access token has expired and we're trying to authenticate without OAuth\n    if (response._status === 401 && !this._userConfig.useBrowserCookies) {\n      let msg = 'Access token required to access this endpoint.';\n      return when.reject(new ResponseError(msg, response, endpoint));\n    }\n\n    // - - -\n    // Reddit servers are busy. Can't do much here.\n\n    if (String(response._status).substring(0, 1) === '5') {\n      let modifiedEndpoint = new Endpoint(this._userConfig,\n                                          endpoint.hostname,\n                                          endpoint.method,\n                                          endpoint.path,\n                                          this.buildHeaders(\n                                            endpoint.contextOptions),\n                                          endpoint.givenArgs,\n                                          endpoint.contextOptions,\n                                          endpoint.port);\n\n      return when.resolve(modifiedEndpoint);\n    }\n\n    // - - -\n    // At the end of the day, we just throw an error stating that there\n    // is nothing we can do & give general advice\n    return when.reject(new ResponseError(\n      ('This call failed. ' +\n       'Does this call require a user? ' +\n       'Is the user missing reddit gold? ' +\n       'Trying to change a subreddit that the user does not moderate? ' +\n       'This is an unrecoverable error. Check the rest of the ' +\n       'error message for more information.'),\n      response,\n      endpoint));\n  }\n\n  /*\n     Handle reddit response status of 2xx.\n\n     Finally return the data if there were no problems.\n   */\n  handleSuccessResponse(response, endpoint) {\n\n    let data = response._body || '';\n\n    if (endpoint.contextOptions.decodeHtmlEntities) {\n      data = he.decode(data);\n    }\n\n    // Attempt to parse some JSON, otherwise continue on (may be empty, or text)\n    try {\n      data = JSON.parse(data);\n\n      // Reddit isn't always honest in their response status. Check for\n      // any errors in 2xx http statuses\n\n      // data.json.errors\n      if (data.json && data.json.errors && data.json.errors.length > 0) {\n        return when.reject(new ResponseError('', response, endpoint));\n      }\n\n      // data.json.error\n      if (data.json && data.json.error) {\n        return when.reject(new ResponseError('', response, endpoint));\n      }\n\n    } catch(e) {}\n\n\n    let rateLimitRemaining = response._headers['x-ratelimit-remaining'];\n    let rateLimitUsed = response._headers['x-ratelimit-used'];\n    let rateLimitReset = response._headers['x-ratelimit-reset'];\n\n    let rateLimitData = {\n      rateLimitRemaining: rateLimitRemaining ? Number(rateLimitRemaining) : void 0,\n      rateLimitUsed: rateLimitUsed ? Number(rateLimitUsed) : void 0,\n      rateLimitReset: rateLimitReset ? Number(rateLimitReset) : void 0\n    };\n\n    if (typeof rateLimitData.rateLimitUsed !== 'undefined') {\n      this.emit('rate_limit', rateLimitData);\n    }\n\n    // Using a test variable\n    // this._userConfig.__test.rateLimitRemainingCutoff\n    // it's default value is \"0\", however in the tests cases this\n    // would take too long.\n    let cutoff = this._userConfig.__test.rateLimitRemainingCutoff;\n\n    if (typeof rateLimitData.rateLimitRemaining !== 'undefined' &&\n      Number(rateLimitRemaining) <= cutoff)\n    {\n      this.emit('rate_limit_reached', rateLimitData);\n    }\n\n    if (this._userConfig.useBrowserCookies && data.data &&\n        data.data.modhash && data.data.modhash.length) {\n      this._modhash.setModhash(data.data.modhash);\n    }\n\n    return when.resolve(data);\n  }\n\n  /*\n     Listing support.\n   */\n  getListing(endpoint) {\n\n    // number of results that we have loaded so far. It will\n    // increase / decrease when calling next / previous.\n    let count = 0;\n    let limit = endpoint.args.limit || 25;\n    // keep a reference to the start of this listing\n    let start = endpoint.args.after || null;\n\n    let getSlice = (endpoint) => {\n\n      return this.callRedditApi(endpoint).then((result={}) => {\n\n        let slice = {};\n        let listing = result;\n\n        slice.get = result;\n\n        if (result instanceof Array) {\n          if (typeof endpoint.contextOptions.listingIndex === 'undefined') {\n            throw new Error('Must specify a `listingIndex` for this listing.');\n          }\n\n          listing = result[endpoint.contextOptions.listingIndex];\n        }\n\n        slice.count = count;\n\n        slice.before = listing.data.before || null;\n        slice.after = listing.data.after || null;\n        slice.allChildren = listing.data.children || [];\n\n        slice.empty = slice.allChildren.length === 0;\n\n        slice.children = slice.allChildren.filter(function(child) {\n          child.data = child.data || {};\n          return !child.data.stickied;\n        });\n\n        slice.stickied = slice.allChildren.filter(function(child) {\n          child.data = child.data || {};\n          return child.data.stickied;\n        });\n\n        slice.next = () => {\n          count += limit;\n\n          let newArgs = endpoint.givenArgs;\n          newArgs.before = null;\n          newArgs.after = slice.children[slice.children.length - 1].data.name;\n          newArgs.count = count;\n          return getSlice(new Endpoint(this._userConfig,\n                                       endpoint.hostname,\n                                       endpoint.method,\n                                       endpoint.path,\n                                       this.buildHeaders(endpoint.contextOptions),\n                                       newArgs,\n                                       endpoint.contextOptions,\n                                       endpoint.port));\n        };\n\n        slice.previous = () => {\n          count -= limit;\n\n          let newArgs = endpoint.givenArgs;\n          newArgs.before = slice.children[0].data.name;\n          newArgs.after = null;\n          newArgs.count = count;\n          return getSlice(new Endpoint(this._userConfig,\n                                       endpoint.hostname,\n                                       endpoint.method,\n                                       endpoint.path,\n                                       this.buildHeaders(endpoint.contextOptions),\n                                       newArgs,\n                                       endpoint.contextOptions,\n                                       endpoint.port));\n        };\n\n        slice.start = () => {\n          count = 0;\n\n          let newArgs = endpoint.givenArgs;\n          newArgs.before = null;\n          newArgs.after = start;\n          newArgs.count = count;\n          return getSlice(new Endpoint(this._userConfig,\n                                       endpoint.hostname,\n                                       endpoint.method,\n                                       endpoint.path,\n                                       this.buildHeaders(endpoint.contextOptions),\n                                       newArgs,\n                                       endpoint.contextOptions,\n                                       endpoint.port));\n        };\n\n        slice.requery = () => {\n          return getSlice(endpoint);\n        };\n\n        return slice;\n      });\n\n    };\n\n    return getSlice(endpoint);\n  }\n\n  /*\n     Enable path syntax support, e.g. this.path('/path/to/$endpoint/etc')\n\n     Can take an url as well, but the first part of the url is chopped\n     off because it is not needed. We will always use the server oauth\n     to call the API...\n\n     e.g. https://www.example.com/api/v1/me\n\n     will only use the path: /api/v1/me\n   */\n  path(urlOrPath) {\n\n    let parsed = urlLib.parse(urlOrPath);\n    let path = parsed.pathname;\n\n    let calls = {};\n\n    ['get', 'post', 'put', 'patch', 'delete', 'update'].forEach(verb => {\n      calls[verb] = (userGivenArgs, userContextOptions) => {\n        return this.callRedditApi(new Endpoint(this._userConfig,\n                                               this._userConfig.serverOAuth,\n                                               verb,\n                                               path,\n                                               this.buildHeaders(userContextOptions),\n                                               userGivenArgs,\n                                               userContextOptions,\n                                               this._userConfig.serverOAuthPort));\n      };\n    });\n\n    // Add listing support\n    calls.listing = (userGivenArgs, userContextOptions) => {\n      return this.getListing(new Endpoint(this._userConfig,\n                                          this._userConfig.serverOAuth,\n                                          'get',\n                                          path,\n                                          this.buildHeaders(userContextOptions),\n                                          userGivenArgs,\n                                          userContextOptions,\n                                          this._userConfig.serverOAuthPort));\n    };\n\n    return calls;\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/Request.js":"import querystring from 'querystring';\nimport events from 'events';\n\nimport when from 'when';\nimport delay from 'when/delay';\n\nimport * as u from './utils';\n\nimport ResponseError from './ResponseError';\n\nimport httpsNode from './https/httpsNode';\nimport httpsBrowser from './https/httpsBrowser';\n\nconst rawHttps = u.isNode() ? httpsNode : httpsBrowser;\n\nexport default class Request extends events.EventEmitter {\n\n  constructor (throttle) {\n    super();\n    this._throttle = throttle;\n  }\n\n  /*\n     Makes an https call with a given endpoint.\n\n     If an error handler is provided, it will call it in\n     the case of a returned status that is not 2xx / success.\n\n     If the errorHandler results in a rejected promise, then we will NOT\n     retry the endpoint and reject with the given error.\n   */\n  https(endpoint, responseErrorHandler) {\n    return this._throttle.wait().then(()=> {\n\n      let reqOptions = {\n        method: endpoint.method.toUpperCase(),\n        hostname: endpoint.hostname,\n        path: endpoint.computedPath,\n        headers: endpoint.headers,\n        useBrowserCookies: endpoint._userConfig.useBrowserCookies\n      };\n\n      // @TODO Node.js has issues if you set it to 80?\n      if (endpoint.port !== 80) {\n        reqOptions.port = endpoint.port;\n      }\n\n      let formData = endpoint.args;\n\n      return rawHttps(reqOptions, formData).timeout(\n        endpoint.contextOptions.requestTimeout,\n        new ResponseError('The request has timed out', {}, endpoint)\n      ).then(response => {\n\n        let statusChar = String(response._status).substring(0, 1);\n        let success = statusChar === '2';\n\n        // If success we're done!\n        if (success) {\n          return response;\n        }\n\n        // Else, retry the endpoint if we can.\n        endpoint.contextOptions.retryAttemptsLeft--;\n\n        let responseError;\n        responseError = new ResponseError('Response Error',\n                                          response,\n                                          endpoint);\n\n        this.emit('response_error', responseError);\n\n        if (endpoint.contextOptions.retryAttemptsLeft <= 0) {\n          responseError.message = ('All retry attempts exhausted.\\n\\n' +\n                                   responseError.message);\n          return when.reject(responseError);\n        }\n\n        // Use the given response error handler, or use a thin wrapper that\n        // will return the endpoint without any modifications\n        responseErrorHandler = responseErrorHandler || function(response, endpoint) {\n          return when.resolve(endpoint);\n        };\n\n        // Call the error handler. If not rejected, retry the endpoint\n        // with any modifications made by the responseErrorHandler\n        return responseErrorHandler(response, endpoint).then(modifiedEndpoint => {\n\n          // Only have a retry delay if the endpoint had an HTTP 5xx status\n          let retryDelay = (statusChar === '5') ?\n                           modifiedEndpoint.contextOptions.retryDelay :\n                           0;\n\n          return delay(retryDelay).then(()=> {\n            return this.https(modifiedEndpoint, responseErrorHandler);\n          });\n        });\n      });\n\n    });\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/ResponseError.js":"/*\n   A uniform way to report response errors.\n*/\nexport default class ResponseError extends Error {\n  constructor(message, response, endpoint) {\n    super();\n\n    this.message = [\n      message,\n      '>>> Response Status: ' + response._status,\n      '>>> Endpoint URL: '+ endpoint.url,\n      '>>> Arguments: ' + JSON.stringify(endpoint.args, null, 2),\n      '>>> Response Body:',\n      response._body\n    ].join('\\n\\n');\n\n    this.url = endpoint.url;\n    this.args = endpoint.args;\n    this.status = response._status;\n    this.body = response._body;\n    this.retryAttemptsLeft = endpoint.contextOptions.retryAttemptsLeft;\n    this.endpoint = endpoint;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/Snoocore.js":"// Node.js libraries\nimport events from 'events';\nimport util from 'util';\n\n// Our modules\nimport Request from './Request';\nimport RedditRequest from './RedditRequest';\nimport Throttle from './Throttle';\nimport UserConfig from './UserConfig';\nimport OAuth from './OAuth';\nimport Modhash from './Modhash';\nimport fileHelper from './https/file';\n\nexport default class Snoocore extends events.EventEmitter {\n\n  static get version() {\n    return '3.2.0';\n  }\n\n  static file(...args) {\n    return fileHelper(...args);\n  }\n\n  constructor(userConfiguration) {\n    super();\n\n    // @TODO - this is a \"god object\" of sorts.\n    this._userConfig = new UserConfig(userConfiguration);\n\n    this._throttle = new Throttle(this._userConfig.throttle);\n\n    this._request = new Request(this._throttle);\n\n    this._request.on('response_error', (responseError) => {\n      this.emit('response_error', responseError);\n    });\n\n    // Two OAuth instances. One for authenticated users, and another for\n    // Application only OAuth. Two are needed in the instance where\n    // a user wants to bypass authentication for a call - we don't want\n    // to waste time by creating a new app only instance, authenticating,\n    // etc.\n    this.oauth = new OAuth(this._userConfig, this._request);\n    this.oauthAppOnly = new OAuth(this._userConfig, this._request);\n\n    // Expose OAuth functions in here\n    [ 'getExplicitAuthUrl',\n      'getImplicitAuthUrl',\n      'getAuthUrl',\n      'auth',\n      'refresh',\n      'deauth',\n      'getRefreshToken',\n      'getAccessToken',\n      'setRefreshToken',\n      'setAccessToken',\n      'hasRefreshToken',\n      'hasAccessToken'\n    ].forEach(fn => { this[fn] = this.oauth[fn].bind(this.oauth); });\n\n    if (this._userConfig.useBrowserCookies) {\n      this.modhash = new Modhash(this._userConfig, this._request);\n\n      // Expose Modhash functions in here\n      [ 'isModhashOld',\n        'setModhash',\n        'getModhash',\n        'getCurrentModhash',\n        'refreshModhash'\n      ].forEach(fn => { this[fn] = this.modhash[fn].bind(this.modhash); });\n    }\n\n    this.appOnlyAuth = this.oauthAppOnly.applicationOnlyAuth.bind(this.oauthAppOnly);\n\n    // Bubble up the  events\n    this.oauth.on('access_token_refreshed', (accessToken) => {\n      this.emit('access_token_refreshed', accessToken);\n    });\n\n\n    this._redditRequest = new RedditRequest(this._userConfig,\n                                            this._request,\n                                            this.oauth,\n                                            this.oauthAppOnly,\n                                            this.modhash);\n\n    this._redditRequest.on('access_token_expired', (responseError) => {\n      this.emit('access_token_expired', responseError);\n    });\n\n    this._redditRequest.on('rate_limit', (rateLimitData) => {\n      this.emit('rate_limit', rateLimitData);\n    });\n\n    this._redditRequest.on('rate_limit_reached', (rateLimitData) => {\n      // let the user know that they have gone over\n      this.emit('rate_limit_reached', rateLimitData);\n      // Delay the next call until the rate limit reset occurs\n      this._throttle.addTime(rateLimitData.rateLimitReset * 1000);\n    });\n\n    /*\n       Make this._redditRequest.path the primary function that we return, but\n       stick the rest of the available functions on the prototype so we\n       can use them as well.\n     */\n    let path = this._redditRequest.path.bind(this._redditRequest);\n\n    let key;\n    for (key in this) {\n      path[key] = this[key];\n    }\n\n    return path;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/Throttle.js":"/*\n   A basic throttle manager. Exposes 1 functoin `wait` that\n   will return a promise that resolves once we've waited the proper\n   amount of time, e.g.\n\n   var throttle = new Throttle();\n\n   throttle.wait() // resolves after 1ms\n   throttle.wait() // resolves after 10001ms\n   throttle.wait() // resolves after 2001ms\n\n */\n\nimport when from 'when';\nimport delay from 'when/delay';\n\nexport default class Throttle {\n\n  constructor(throttleMs=1000) {\n\n    this._throttleMs = throttleMs;\n\n    /*\n       The current throttle delay before a request will go through\n       increments every time a call is made, and is reduced when a\n       call finishes.\n\n       Time is added & removed based on the throttle variable.\n     */\n    this._throttleDelay = 1;\n  }\n\n  wait() {\n    // resolve this promise after the current throttleDelay\n    let delayPromise = delay(this._throttleDelay);\n\n    // add throttleMs to the total throttleDelay\n    this._throttleDelay += this._throttleMs;\n\n    // after throttleMs time, subtract throttleMs from\n    // the throttleDelay\n    setTimeout(()=> {\n      this._throttleDelay -= this._throttleMs;\n    }, this._throttleMs);\n\n    return delayPromise;\n  }\n\n  /*\n     Time in milliseconds to add to the throttle delay\n  */\n  addTime(timeMs) {\n    this._throttleDelay += timeMs;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/UserConfig.js":"import * as u from './utils';\n\n/*\n   A class made up of the user configuration.\n\n   Normalizes the configuraiton & checks for simple errors.\n\n   Provides some helper functons for getting user set values.\n */\n\nexport default class UserConfig {\n  constructor(userConfiguration) {\n\n    //\n    // - - - CONFIGURATION VALUES - - -\n    //\n\n    var missingMsg = 'Missing required userConfiguration value ';\n\n    // ** IDENFIFICATION\n    this.userAgent = u.thisOrThrow(\n      userConfiguration.userAgent,\n      'Missing required userConfiguration value `userAgent`');\n\n    this.isNode = u.thisOrThat(userConfiguration.browser, u.isNode());\n\n    this.mobile = u.thisOrThat(userConfiguration.mobile, false);\n\n    this.useBrowserCookies = u.thisOrThat(userConfiguration.useBrowserCookies, false);\n\n    if (userConfiguration.apiServerUri) {\n      userConfiguration.serverOAuth = userConfiguration.apiServerUri;\n    }\n\n    if (userConfiguration.authServerUri) {\n      userConfiguration.serverWWW = userConfiguration.authServerUri;\n    }\n\n    // ** SERVERS\n    if (this.useBrowserCookies) {\n      this.serverOAuth = u.thisOrThat(userConfiguration.serverOAuth,\n                                      'www.reddit.com');\n    } else {\n      this.serverOAuth = u.thisOrThat(userConfiguration.serverOAuth,\n                                      'oauth.reddit.com');\n    }\n\n    this.serverWWW = u.thisOrThat(userConfiguration.serverWWW,\n                                  'www.reddit.com');\n    this.serverOAuthPort = u.thisOrThat(userConfiguration.serverOAuthPort, 80);\n    this.serverWWWPort = u.thisOrThat(userConfiguration.serverWWWPort, 80);\n\n    // ** CALL MODIFICATIONS\n    this.throttle = u.thisOrThat(userConfiguration.throttle, 1000);\n\n    this.decodeHtmlEntities = u.thisOrThat(\n      userConfiguration.decodeHtmlEntities,\n      false);\n\n    this.apiType = u.thisOrThat(userConfiguration.apiType, 'json');\n\n\n    // ** RETRY ATTEMPTS\n    this.retryAttempts = u.thisOrThat(userConfiguration.retryAttempts, 60);\n\n    this.retryDelay = u.thisOrThat(userConfiguration.retryDelay, 5000);\n\n    this.requestTimeout = u.thisOrThat(userConfiguration.requestTimeout, 20000);\n\n\n    // ** OAUTH\n    this.oauth = u.thisOrThat(userConfiguration.oauth, {});\n\n    this.oauth.scope = u.thisOrThat(this.oauth.scope, []);\n\n    this.oauth.deviceId = u.thisOrThat(this.oauth.deviceId,\n                                       'DO_NOT_TRACK_THIS_DEVICE');\n    this.oauth.duration = u.thisOrThat(this.oauth.duration, 'temporary');\n\n    if (this.useBrowserCookies) {\n      this.oauth.type = u.thisOrThat(this.oauth.type, '');\n      this.oauth.key = u.thisOrThat(this.oauth.key, '');\n    } else {\n      this.oauth.type = u.thisOrThrow(this.oauth.type,\n                                      missingMsg + '`oauth.type`');\n      this.oauth.key = u.thisOrThrow(this.oauth.key,\n                                     missingMsg + '`oauth.key`');\n    }\n\n\n    //\n    // - - - VALIDATION\n    //\n\n    if (this.oauth.duration !== 'temporary' &&\n      this.oauth.duration !== 'permanent')\n    {\n      throw new Error(\n        'Invalid `oauth.duration`. Must be one of: permanent, temporary');\n    }\n\n    if (this.oauth.deviceId !== 'DO_NOT_TRACK_THIS_DEVICE' &&\n      (this.oauth.deviceId.length < 20 || this.oauth.deviceId.length > 30)) {\n        throw new Error(\n          'Invalid device_id length. Must be 20-30 characters');\n    }\n\n    if (!this.isOAuthType('explicit') &&\n      !this.isOAuthType('implicit') &&\n      !this.isOAuthType('script') &&\n      !this.useBrowserCookies)\n    {\n      throw new Error(\n        'Invalid `oauth.type`. Must be one of: explicit, implicit, or script');\n    }\n\n    if (!this.useBrowserCookies) {\n      if (this.isOAuthType('explicit') || this.isOAuthType('script')) {\n        this.oauth.secret = u.thisOrThrow(\n          this.oauth.secret,\n          missingMsg + '`oauth.secret` for type explicit/script');\n      }\n\n\n      if (this.isOAuthType('script')) {\n        this.oauth.username = u.thisOrThrow(\n          this.oauth.username,\n          missingMsg + '`oauth.username` for type script');\n        this.oauth.password = u.thisOrThrow(\n          this.oauth.password,\n          missingMsg + '`oauth.password` for type script');\n      }\n\n      if (this.isOAuthType('implicit') || this.isOAuthType('explicit')) {\n        this.oauth.redirectUri = u.thisOrThrow(\n          this.oauth.redirectUri,\n          missingMsg + '`oauth.redirectUri` for type implicit/explicit');\n      }\n    }\n\n\n    //\n    // TESTING CONFIGURATION\n    //\n    // Some test cases require some deep messing around with the library\n    // in order to be nice to the API server when testing.\n    //\n    // These should never be used by anything other than the test cases to\n    // modify internal variables. They are only used if needed!\n\n    /*\n       Used to determine when we have gone over the rate limit. The default\n       would be \"0\", e.g. when there are not more requests remaining in the\n       current time slot\n     */\n    this.__test = {};\n    userConfiguration.__test = userConfiguration.__test || {};\n\n    this.__test.rateLimitRemainingCutoff = u.thisOrThat(\n      userConfiguration.__test.rateLimitRemainingCutoff, 0);\n  }\n\n  /*\n     Checks if the oauth is of a specific type, e.g.\n\n     isOAuthType('script')\n   */\n  isOAuthType(type) {\n    return this.oauth.type === type;\n  }\n\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/utils.js":"\n// checks basic globals to help determine which environment we are in\nexport function isNode() {\n  return typeof require === \"function\" &&\n  typeof exports === \"object\" &&\n  typeof module === \"object\" &&\n  typeof window === \"undefined\";\n}\n\n/*\n   Return the value of `tryThis` unless it's undefined, then return `that`\n */\nexport function thisOrThat(tryThis, that) {\n  return (typeof tryThis !== 'undefined') ? tryThis : that;\n}\n\n/*\n   Return the value of `tryThir` or throw an error (with provided message);\n */\nexport function thisOrThrow(tryThis, orThrowMessage) {\n  if (typeof tryThis !== 'undefined') { return tryThis; }\n  throw new Error(orThrowMessage);\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/https/file.js":"/*\nRepresents a file that we wish to upload to reddit.\n\nAll files have a name, mimeType, and data. \n\nIn the browser data can be a `File` object directly from\na file input, or a `Blob` object.\n\nIn node, data can be a `utf8` string, or a buffer\ncontaining the content of the file.\n*/\n\nexport default function(name, mimeType, data) {\n  var self = {};\n\n  self.name = name;\n  self.mimeType = mimeType;\n\n  if (typeof File !== 'undefined' && data instanceof File ||\n      typeof Blob !== 'undefined' && data instanceof Blob) {\n    self.data = data;\n  } else {\n    self.data = (typeof data === 'string') ? new Buffer(data) : data;\n  }\n\n  return self;\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/https/form.js":"\nimport querystring from 'querystring';\n\nimport when from 'when';\n\nexport function getSectionBoundary(boundary) {\n  return '--' + boundary;\n}\n\nexport function getEndBoundary(boundary) {\n  return '--' + boundary + '--';\n}\n\nexport function encodeFieldPart(boundary, key, value) {\n  return new Buffer([\n    getSectionBoundary(boundary),\n    '\\r\\n',\n    'Content-Disposition: form-data; name=\"' + key + '\"',\n    '\\r\\n\\r\\n',\n    value,\n    '\\r\\n'\n  ].join(''));\n}\n\nexport function encodeFilePart(boundary, key, name, mimeType, data) {\n  return Buffer.concat([\n    new Buffer([\n      getSectionBoundary(boundary),\n      '\\r\\n',\n      ('Content-Disposition: form-data; ' +\n       'name=\"' + key + '\"; ' +\n       'filename=\"' + name + '\"'),\n      '\\r\\n',\n      'Content-Type: ' + mimeType,\n      '\\r\\n\\r\\n'\n    ].join('')),\n    data, // already a buffer\n    new Buffer('\\r\\n')\n  ]);\n}\n\n/*\n   Converts a list of parameters to form data\n\n   - `fields` - a property map of key value pairs\n   - `files` - a list of property maps of content\n   --> `type` - the type of file data\n   --> `keyname` - the name of the key corresponding to the file\n   --> `valuename` - the name of the value corresponding to the file\n   --> `dataBuffer` - A buffer containing the files data\n */\nexport function getMultipartFormData(boundary, fields, files) {\n\n  var dataBuffer = new Buffer(0);\n  var key;\n\n  if (fields) {\n    for (key in fields) {\n      // skip over any file fields\n      if (key === 'file') { continue; }\n\n      var value = fields[key];\n\n      dataBuffer = Buffer.concat([\n        dataBuffer, encodeFieldPart(boundary, key, value)\n      ]);\n    }\n  }\n\n  if (files) {\n    for (key in files) {\n      var file = files[key];\n\n      dataBuffer = Buffer.concat([\n        dataBuffer,\n        encodeFilePart(boundary,\n                       file.key,\n                       file.name,\n                       file.mimeType,\n                       file.data)\n      ]);\n    }\n  }\n\n  // close with a final boundary closed with '--' at the end\n  dataBuffer = Buffer.concat([\n    dataBuffer,\n    new Buffer(getEndBoundary(boundary))\n  ]);\n\n  return dataBuffer;\n}\n\n/*\n   Takes an existing string or key-value pair that represents form data\n   and returns form data in the form of an Array.\n\n   If the formData is an object, and that object has a 'file' key,\n   we will assume that it is going to be a multipart request and we\n   will also assume that the file is actually a file path on the system\n   that we wish to use in the multipart data.\n */\nexport function getData(formData) {\n\n  var data = {\n    contentType: 'application/x-www-form-urlencoded',\n    contentLength: 0,\n    buffer: new Buffer(0)\n  };\n\n  // The data is already in a string format. There is nothing\n  // to do really\n  if (typeof formData === 'string') {\n    data.buffer = new Buffer(formData);\n  }\n\n  if (typeof formData === 'object') {\n    // The data is an object *without* a file key. We will assume\n    // that we want this data in an url encoded format\n    if (!formData.file) {\n      data.buffer = new Buffer(querystring.stringify(formData));\n    } else {\n      // for now we only have to handle one file, with one key name of 'file'\n      var singleFile = formData.file;\n      singleFile.key = 'file';\n\n      var files = [ formData.file ];\n\n      var boundary = '---------Snoocore' + Math.floor(Math.random() * 10000);\n      data.contentType = 'multipart/form-data; boundary=' + boundary;\n      data.buffer = getMultipartFormData(boundary, formData, files);\n    }\n  }\n\n  data.contentLength = data.buffer.length;\n  return data;\n}\n\n/*\n   Takes an key-value pair and turns them into a FormData object. This is for when\n   we want to upload a file using XMLHttpRequest.\n*/\n\nexport function getFormData(formData) {\n  var data = new FormData();\n\n  for (var key in formData) {\n    if (key === 'file') {\n      data.append(key, formData[key].data, formData[key].name);\n    } else {\n      data.append(key, formData[key]);\n    }\n  }\n\n  return data;\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/https/httpsBrowser.js":"//\n// Browser requests, mirrors the syntax of the node requests\n//\n\nimport urlLib from 'url';\n\nimport when from 'when';\n\nimport * as form from './form';\n\n// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#getAllResponseHeaders()\n\n// Set to true to print useful http debug information on a lower level\nlet DEBUG_LOG = false ? console.error : ()=>{};\n\n/**\n * Modified from https://gist.github.com/monsur/706839\n *\n * XmlHttpRequest's getAllResponseHeaders() method returns a string of response\n * headers according to the format described here:\n * http://www.w3.org/TR/XMLHttpRequest/#the-getallresponseheaders-method\n * This method parses that string into a user-friendly key/value pair object.\n */\nfunction parseResponseHeaders(headerStr) {\n  let headers = {};\n  if (!headerStr) {\n    return headers;\n  }\n  let headerPairs = headerStr.split('\\u000d\\u000a');\n  for (let i = 0, len = headerPairs.length; i < len; i++) {\n    let headerPair = headerPairs[i];\n    // Can't use split() here because it does the wrong thing\n    // if the header value has the string \": \" in it.\n    let index = headerPair.indexOf('\\u003a\\u0020');\n    if (index > 0) {\n      // make all keys lowercase\n      let key = headerPair.substring(0, index).toLowerCase();\n      let val = headerPair.substring(index + 2);\n      headers[key] = val;\n    }\n  }\n  return headers;\n}\n\nexport default function https(options, formData) {\n\n  DEBUG_LOG('>> browser https call');\n\n  options = options || {};\n  options.headers = options.headers || {};\n\n  var data;\n\n  if (formData.file) {\n    data = form.getFormData(formData);\n  } else {\n    data = form.getData(formData);\n    options.headers['Content-Type'] = data.contentType;\n  }\n\n  return when.promise((resolve, reject) => {\n\n    try {\n      if (options.method === 'GET' && data instanceof FormData) {\n        return reject(new Error(\n          'Cannot make a GET request while handling a file!'));\n      }\n\n      // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n      var x = new window.XMLHttpRequest();\n\n      var url = 'https://' + options.hostname + options.path;\n\n      DEBUG_LOG('>> url: ', url);\n\n      // append the form data to the end of the url\n      if (options.method === 'GET') {\n        url += '?' + data.buffer.toString();\n      }\n\n      x.open(options.method, url, true);\n\n      if (options.useBrowserCookies) {\n        x.withCredentials = true;\n      }\n\n      Object.keys(options.headers).forEach(headerKey => {\n        x.setRequestHeader(headerKey, options.headers[headerKey]);\n      });\n\n      x.onreadystatechange = () => {\n        if (x.readyState > 3) {\n          // Normalize the result to match how requestNode.js works\n\n          DEBUG_LOG('finished...', x.status);\n\n          return resolve({\n            _body: x.responseText,\n            _status: x.status,\n            _headers: parseResponseHeaders(x.getAllResponseHeaders())\n          });\n        }\n      };\n\n      if (data instanceof FormData) {\n        x.send(data);\n      } else {\n        x.send(options.method === 'GET' ? null : data.buffer.toString());\n      }\n\n    } catch (e) {\n      return reject(e);\n    }\n\n  }).then(res => {\n    let canRedirect = (String(res._status).substring(0, 1) === '3' &&\n      typeof res._headers.location !== 'undefined');\n\n    if (canRedirect) {\n      // Make the call again with the new hostname, path, and form data\n      let parsed = urlLib.parse(res._headers.location);\n      options.hostname = parsed.hostname;\n      options.path = parsed.pathname;\n      return https(options, parsed.query);\n    }\n\n    return res;\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-snoocore/node_modules/snoocore/src/https/httpsNode.js":"//\n// Node requests\n//\n\nimport httpsLib from 'https';\nimport urlLib from 'url';\n\nimport when from 'when';\n\nimport * as form from './form';\n\n// Set to true to print useful http debug information on a lower level\nlet DEBUG_LOG = false ? console.error : ()=>{};\n\n/*\n   Form data can be a raw string, or an object containing key/value pairs\n */\nexport default function https(options, formData) {\n  DEBUG_LOG('\\n\\n\\n\\n');\n  DEBUG_LOG('>>> request:\\n' +\n            options.method + ': ' +\n            options.hostname +\n            options.path);\n\n  options = options || {};\n  options.headers = options.headers || {};\n\n  formData = formData || [];\n\n  let data = form.getData(formData);\n\n  options.headers['Content-Type'] = data.contentType;\n\n  if (options.method !== 'GET') {\n    options.headers['Content-Length'] = data.contentLength;\n  }\n\n  DEBUG_LOG('\\n>>> request headers\\n', options.headers);\n\n  // stick the data at the end of the url for GET requests\n  if (options.method === 'GET' && data.buffer.toString() !== '') {\n    DEBUG_LOG('\\n>>> query string:\\n', data.buffer.toString());\n    options.path += '?' + data.buffer.toString();\n  }\n\n  return when.promise(function(resolve, reject) {\n\n    let req = httpsLib.request(options, function(res) {\n\n      res._req = req; // attach a reference back to the request\n\n      res.setEncoding('utf8');\n      let body = '';\n      res.on('error', error => { return reject(error); });\n      res.on('data', chunk => { body += chunk; });\n      res.on('end', () => {\n        res._body = body; // attach the response body to the object\n        res._status = res.statusCode;\n        res._headers = res.headers;\n        DEBUG_LOG('\\n>>> response headers:\\n', res._headers);\n        DEBUG_LOG('\\n>>> response body:\\n', String(body).substring(0, 1000));\n        DEBUG_LOG('\\n>>> status:\\n', res.statusCode);\n        return resolve(res);\n      });\n    });\n\n    req.on('error', error => { return reject(error); });\n\n    if (options.method !== 'GET') {\n      DEBUG_LOG('\\n>>> request body:\\n', data.buffer.toString());\n      req.write(data.buffer);\n    }\n\n    req.end();\n\n  }).then(res => {\n    let canRedirect = (String(res._status).substring(0, 1) === '3' &&\n      typeof res._headers.location !== 'undefined');\n\n    if (canRedirect) {\n      // Make the call again with the new hostname, path, and form data\n      let parsed = urlLib.parse(res._headers.location);\n      options.hostname = parsed.hostname;\n      options.path = parsed.pathname;\n      return https(options, parsed.query);\n    }\n\n    return res;\n  });\n\n}\n"}